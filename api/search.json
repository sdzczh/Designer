[{"id":"743b68934be546ac8b4b7cd46c619570","title":"一些简单的 Gas 优化基础","content":"编写智能合约是很难的。不仅是要确保代码没有漏洞，而且你的编写方式还会影响到用户与它交互时的开销。\n当你在编译智能合约时，每一行 Solidity 代码都会转换为一系列的操作(操作码)，这些操作都有对应的 gas 消耗。你的目标就是要让你的程序使用尽可能少的操作码(或者用更便宜的)。\n当然，这些都很复杂，所以，我们要慢慢来。与其陷入操作码兔子洞，不如尝试一些可以直接应用到合约里的简单优化。\n升级 Solidity 版本合约中，Solidity 版本是在文件最顶部定义的，像这样：\npragma solidity ^0.8.0;\n在这里，^0.8.0意思是合约使用0.8.x系列最新可用的Solidity版本。\n更新的 Solidity 版本有时会在修复bug和安全补丁时就优化了 gas ，所以，升级到最新版本不仅会让你的代码更安全，通常也会更便宜。\n要捕获最近大多数优化，请确保你的版本在0.8.4以上：\npragma solidity ^0.8.4;\n放弃 Counters.sol如果你的 NFT 项目或者代币正在使用 OpenZeppelin 合约，很可能你正在用 OZ 的Counters.sol库。\n在较新的 Solidity 版本(0.8的更高版本)，这个库并不是很有用，用常规整数替代它可以节省一些gas：\ncontract TestCounters &#123;\n-\tusing Counters for Counters.Counter;\n-\tCounters.Counter private _tokenIds;\n\t\n+\tuint256 private _tokenId;\n\t\n\tfunction mint() public &#123;\n-\t\t_tokenIds.increment();\n-\t\tuint256 tokenId &#x3D; _tokenIds.current();\n\t\t\n+\t\tuint256 tokenId &#x3D; _tokenId++;\n\t&#125;\n&#125;\n标记不可变变量无论是代币的小数位数，USDC 的地址，还是支付账户，有时我们并不打算更改合约变量。此时，将它们标记为常量（如果你在代码中编写它们）或者不可变量（如果你计划之后给它们赋值，比如，通过构造函数）可以降低访问这些值时的开销：\ncontract TestImmutable &#123;\n\tuint256 internal constant DECIMALS &#x3D; 18;\n\taddress public immutable currencyToken;\n\t\n\tconstructor(address _currencyToken) &#123;\n\t\tcurrencyToken &#x3D; _currencyToken;\n\t&#125;\n&#125;\nunchecked {}从 Solidity 0.8开始，所有数学运算都包括溢出检查。这是很棒的（替换了 SafeMath 库，如果你还在用可以丢弃了），但是它需要额外的 gas 开销，所以我们想在不必要的时候绕开它。\n溢出检查的意义在于帮你检查是否存在从 0 减去或者加到 2256 （Solidity 可以处理的最大数）以上。所以，如果你只是增加代币id或者存储ERC20值，你应该用unchecked &#123;&#125;退出溢出检查：\ncontract TestUnchecked is ERC721 &#123;\n\tERC20 internal immutable paymentToken &#x3D; ERC20(address(0x1));\n\tuint256 internal _tokenId;\n\t\n\tmapping(address &#x3D;&gt; uint256) _balances;\n\t\n\tfunction mint(uint256 amount) public &#123;\n\t\t_mint(msg.sender, _tokenId);\n\t\t\n\t\tunchecked &#123;\n\t\t\t_balances[msg.sender] +&#x3D; amount;\n\t\t\t++tokenId;\n\t\t&#125;\n\t\t\n\t\tpaymentToken.transferFrom(msg.sender, address(this), amount);\n\t&#125;\n&#125;\n这在for循环中特别方便，i的值永远不会溢出，所以在每次迭代中节省了gas：\ncontract TestUncheckedFor &#123;\n\tERC20 internal immutable token &#x3D; ERC20(address(0x1));\n\n\tfunction refundAddresses(address[] calldata accounts) &#123;\n\t\t&#x2F;&#x2F; 💡 pro tip: save the array length to a variable instead of\n\t\t&#x2F;&#x2F; inlining to save gas on every iteration.\n\t\tuint256 len &#x3D; accounts.length;\n\t\t\n\t\tfor (uint256 i &#x3D; 0; i &lt; len; ) &#123;\n\t\t\ttoken.transfer(accounts[i], 1 ether);\n\t\t\t\n\t\t\tunchecked &#123; ++i; &#125;\n\t\t&#125;\n\t&#125;\n&#125;\n避免将参数复制到内存对于某些类型的参数，如字符串或者数组，Solidity 会强制指定存储位置(memory或者calldata)。这里用calldata会便宜的多，所以你会希望尽可能多的使用它，而memory只在你需要修改参数时才用（因为calldata会让它们只读）。\n使用自定义错误Solidity 0.8.4有一个新功能，允许开发者自定义错误，就像定义事件一样：\ncontract TestErrors &#123;\n\t&#x2F;&#x2F; first, define the error\n\terror Unauthorized();\n\t\n\t&#x2F;&#x2F; errors can have parameters, like events\n\terror AlreadyMinted(uint256 id);\n\t\n\t&#x2F;&#x2F; 💡 pro tip: this gets set to the deployer address\n\t&#x2F;&#x2F; sometimes, you don&#39;t need Ownable :)\n\taddress internal immutable owner &#x3D; msg.sender;\n\t\n\tmapping(uint256 &#x3D;&gt; address) _ownerOf;\n\t\n\tfunction ownerMint(uint256 tokenId) public &#123;\n\t\tif (msg.sender !&#x3D; owner) revert Unauthorized();\n\t\tif (_ownerOf[tokenId] !&#x3D; address(0)) revert AlreadyMinted(tokenId);\n\t\t\n\t\t_ownerOf[tokenId] &#x3D; msg.sender;\n\t&#125;\n&#125;\n你应该尝试用自定义错误代替以前的返回字符串(require(true, &quot;error message here&quot;))，因为不同的错误信息可能会额外增加gas开销。\n其他当使用任何一种计数器（如_tokenId），从1开始而不是从0开始，会让第一次 mint 便宜一些。通常，写入没有值的槽比写入有值的槽更贵。\n此外，整数递增，++i(返回上一次的值，然后再加1)比i++(加1，然后返回新的值)更便宜。如果你仅仅需要一个计数器而不需要它的返回值，你可能会更想要第一种。\n除法，Solidity 插入了一个检查，确保没有被0除。如果你可以确定除数不为0，你可以使用汇编来执行操作，这样可以节省一些额外的gas：\ncontract TestDivision &#123;\n\tfunction divide_by_2(uint256 a) public pure returns (uint256 result) &#123;\n\t\tassembly &#123;\n\t\t\tresult :&#x3D; div(a, 2)\n\t\t&#125;\n\t&#125;\n&#125;\n最后，标记为payable的函数会比其他函数调用时便宜。将所有函数标记为 payable 可能会影响用户体验，因为在使用 Etherscan 时会有一个额外字段，可能会意外向合约发送 ETH 。相对安全的优化是将构造函数标记为payable，可以稍微降低一点部署的开销。\n结束虽然很难，但 Solidity 和 EVM 的世界真的很有意思。有些开发者可能花费数天时间来调整代码，只为压缩一点额外的gas消耗。\n我希望上面的清单可以成为一个好的参考，帮助你的合约便宜一点。\n","slug":"一些简单的-Gas-优化基础/index","date":"2022-03-24T13:28:30.000Z","categories_index":"Solidity","tags_index":"区块链,百科","author_index":"Bug Designer"},{"id":"c818a12081dd186c3b840bc9579f9407","title":"浅谈NFT的元数据标准","content":"前言为OpenSea等平台提供资产元数据可以为数字资产提供丰富的数据并轻松地在应用程序中显示它们。给定智能合约上的数字资产通常仅由唯一标识符（例如，ERC721 中的 token_id表示，因此元数据允许这些资产具有其他属性，例如名称、描述和图像。\n实现令牌URI为了让 OpenSea 为 ERC721 和 ERC1155 资产提取链下元数据，您的合约需要返回一个 URI，我们可以在其中找到元数据。为了找到这个URI，我们使用ERC721中的方法和ERC1155中的方法。首先，让我们仔细看看Creature 合约中的方法。\n&#x2F;**\n * @dev Returns an URI for a given token ID\n *&#x2F;\nfunction tokenURI(uint256 _tokenId) public view returns (string) &#123;\n  return Strings.strConcat(\n      baseTokenURI(),\n      Strings.uint2str(_tokenId)\n  );\n&#125;\nERC721 中的函数或ERC1155合约中的函数应返回 HTTP 或 IPFS URL，例如https://opensea-creatures-api.herokuapp.com/api/creature/3。查询时，此 URL 应反过来返回一个 JSON 数据块，其中包含您的令牌的元数据。\n元数据结构OpenSea 支持根据官方 ERC721 元数据标准或Enjin 元数据建议构建的元数据。\n此外，我们还支持其他几个允许多媒体附件的属性（包括音频、视频和 3D 模型）以及您的项目的交互式特征，为您提供 OpenSea 市场上的所有排序和过滤功能。\n以下是其中一种 OpenSea 生物的元数据示例：\n&#123;\n  &quot;description&quot;: &quot;Friendly OpenSea Creature that enjoys long swims in the ocean.&quot;, \n  &quot;external_url&quot;: &quot;https:&#x2F;&#x2F;openseacreatures.io&#x2F;3&quot;, \n  &quot;image&quot;: &quot;https:&#x2F;&#x2F;storage.googleapis.com&#x2F;opensea-prod.appspot.com&#x2F;puffs&#x2F;3.png&quot;, \n  &quot;name&quot;: &quot;Dave Starbelly&quot;,\n  &quot;attributes&quot;: [ ... ], \n&#125;\n\n\n\n\nimage\n这是项目图像的 URL。可以是几乎任何类型的图像（包括 SVG，OpenSea 将缓存到 PNG），并且可以是IPFS URL 或路径。我们建议使用 350 x 350 的图像。\n\n\n\nimage_data\n原始 SVG 图像数据，如果您想动态生成图像（不推荐）。仅当您不包含参数时才使用它。\n\n\nexternal_url\n这是显示在 OpenSea 上资产图像下方的 URL，允许用户离开 OpenSea 并在您的站点上查看该项目。\n\n\ndescription\n项目描述。\n\n\nname\n项目的名称。\n\n\nattributes\n这些是项目的属性，将显示在项目的 OpenSea 页面上。\n\n\nbackground_color\nOpenSea 上项目的背景颜色。必须是不带前置 # 的六字符十六进制。\n\n\nanimation_url\n项目多媒体附件的 URL。支持文件扩展名 GLTF、GLB、WEBM、MP4、M4V、OGV 和 OGG，以及仅音频扩展名 MP3、WAV 和 OGA。\n\n\nAnimation_url 还支持 HTML 页面，允许您使用 JavaScript 画布、WebGL 等构建丰富的体验和交互式 NFT。现在支持 HTML 页面中的脚本和相对路径。但是，不支持访问浏览器扩展。 || youtube_url      | YouTube 视频的 URL。                                                                                                                                                                                                                                                 |\n属性为了让您的项目更有活力，我们还允许您将自定义“属性”添加到您的元数据中，这些属性将显示在您的每个资产下方。例如，以下是其中一种 OpenSea 生物的属性。为了生成这些属性，元数据中包含以下属性数组：\n...\n&#123;\n&quot;attributes&quot;: [\n    &#123;\n      &quot;trait_type&quot;: &quot;Base&quot;, \n      &quot;value&quot;: &quot;Starfish&quot;\n    &#125;, \n    &#123;\n      &quot;trait_type&quot;: &quot;Eyes&quot;, \n      &quot;value&quot;: &quot;Big&quot;\n    &#125;, \n    &#123;\n      &quot;trait_type&quot;: &quot;Mouth&quot;, \n      &quot;value&quot;: &quot;Surprised&quot;\n    &#125;, \n    &#123;\n      &quot;trait_type&quot;: &quot;Level&quot;, \n      &quot;value&quot;: 5\n    &#125;, \n    &#123;\n      &quot;trait_type&quot;: &quot;Stamina&quot;, \n      &quot;value&quot;: 1.4\n    &#125;, \n    &#123;\n      &quot;trait_type&quot;: &quot;Personality&quot;, \n      &quot;value&quot;: &quot;Sad&quot;\n    &#125;, \n    &#123;\n      &quot;display_type&quot;: &quot;boost_number&quot;, \n      &quot;trait_type&quot;: &quot;Aqua Power&quot;, \n      &quot;value&quot;: 40\n    &#125;, \n    &#123;\n      &quot;display_type&quot;: &quot;boost_percentage&quot;, \n      &quot;trait_type&quot;: &quot;Stamina Increase&quot;, \n      &quot;value&quot;: 10\n    &#125;, \n    &#123;\n      &quot;display_type&quot;: &quot;number&quot;, \n      &quot;trait_type&quot;: &quot;Generation&quot;, \n      &quot;value&quot;: 2\n    &#125;\n  ]\n&#125;\n日期特征OpenSea 还支持. 这种类型的特征将出现在“排名”和“统计”附近的右栏中。传入一个 unix 时间戳（秒）作为值.\n&#123;\n  &quot;display_type&quot;: &quot;date&quot;, \n  &quot;trait_type&quot;: &quot;birthday&quot;, \n  &quot;value&quot;: 1546360800\n&#125;\n\nIPFS 和 Arweave URIOpenSea 支持将 NFT 元数据存储在分散的文件网络中，因此它们不能被中央方修改。\n如果您使用IPFS来托管元数据，则您的URL应采用ipfs://&lt;hash&gt;. 例如ipfs://QmTy8w65yBXgyfG2ZBg5TrfB2hPjrDQH3RCQFJGkARStJb。\nArweave的等价物是. 例如ar://&lt;hash&gt;。ar://&lt;hash&gt;ar://jK9sR4OrYvODj7PD3czIAyNJalub0-vdV_JAg1NqQ-o\n","slug":"浅谈NFT的元数据标准/index","date":"2022-03-19T14:38:20.000Z","categories_index":"NFT","tags_index":"区块链,NFT,百科","author_index":"Bug Designer"},{"id":"0611b829126354c2a4ab4275e956e0b0","title":"通缩分红币Safemoon解读","content":"1、Safemoon原理Safemoon是一种通缩分红币，通缩指的是每次转账都会收取一定手续费，这些手续费会直接销毁，进而导致总量的通缩。分红指的是，用户的余额会随着其他用户转账而增加。\nSafemoon的基本原理用一个比喻来说就是，将一块固定蛋糕（_tTotal）分给总量会变化的盘子中（_rTotal），每次转账都会打碎一部分盘子，这样剩余盘子分到的蛋糕就变多了。\n2、 数据结构mapping (address &#x3D;&gt; uint256) private _rOwned;\nmapping (address &#x3D;&gt; uint256) private _tOwned;\nmapping (address &#x3D;&gt; mapping (address &#x3D;&gt; uint256)) private _allowances;\n \nmapping (address &#x3D;&gt; bool) private _isExcludedFromFee;\n \nmapping (address &#x3D;&gt; bool) private _isExcluded;\naddress[] private _excluded;\n   \nuint256 private constant MAX &#x3D; ~uint256(0);\nuint256 private _tTotal &#x3D; 1000000000 * 10**6 * 10**9;\nuint256 private _rTotal &#x3D; (MAX - (MAX % _tTotal));\nuint256 private _tFeeTotal;\n \nstring private _name &#x3D; &quot;SafeMoon&quot;;\nstring private _symbol &#x3D; &quot;SAFEMOON&quot;;\nuint8 private _decimals &#x3D; 9;\n\nuint256 public _taxFee &#x3D; 5;\nuint256 private _previousTaxFee &#x3D; _taxFee;\n\nuint256 public _liquidityFee &#x3D; 5;\nuint256 private _previousLiquidityFee &#x3D; _liquidityFee;\n \nIUniswapV2Router02 public immutable uniswapV2Router;\naddress public immutable uniswapV2Pair;\n\nbool inSwapAndLiquify;\nbool public swapAndLiquifyEnabled &#x3D; true;\n\nuint256 public _maxTxAmount &#x3D; 5000000 * 10**6 * 10**9;\nuint256 private numTokensSellToAddToLiquidity &#x3D; 500000 * 10**6 * 10**9;\n_tTotal：对外展示的币总量，为1000000000 * 106 * 109，可以看出是总的蛋糕\n_rTotal：是内部实际的币总量，为2^256-(2^256%_tTotal)，是一个很大的数，可以看出是盘子的数量\n_rOwned : 用户内部持有的实际币数量，可以看成是每个用户拥有的盘子数量\n_tOwned ：只用于非分红用户的转账，可以看成是一个帮助类\n_allowances：类似于ERC20的allowance，指用户授权某些账户的可使用额度\n_isExcludedFromFee：账户白名单，用来判断是否需要转账手续费\n_isExcluded：账户黑名单，用来判断是否参与分红，默认所有用户都会参与分红\n_excluded：黑名单数组\n_tFeeTotal：收取的手续费，可以看成是打碎了多少盘子，但是不影响总蛋糕_tTotal\n_name：代币名称\n_symbol：代币代码\n_decimals：代币精度\n_taxFee：转账收取的手续费，这部分手续费会直接销毁，进而导致_rTotal减少，也就是总量的通缩。\n_previousTaxFee：上一次设置的手续费，是个历史记录\n_liquidityFee：转账收取的流动性手续费，这部分手续费会添加到uniswap的交易对里\n_previousLiquidityFee：上一次设置的手续费，是个历史记录\nuniswapV2Router：uniswap的路由器，用于添加流动性\nuniswapV2Pair：在uniswap的创建的SafeMoon-ETH交易对\ninSwapAndLiquify：用于lockTheSwap这个modifier，用来加锁的\nswapAndLiquifyEnabled：开关，要不要将流动性手续费添加到uniswap的交易对里\n_maxTxAmount：每次转账最多可转多少代币\nnumTokensSellToAddToLiquidity：当累积的流动性手续费大于这个值得时候，才会去uniswap添加流动性\n3、构造函数constructor () public &#123;\n        _rOwned[_msgSender()] &#x3D; _rTotal;\n        \n        IUniswapV2Router02 _uniswapV2Router &#x3D; IUniswapV2Router02(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n         &#x2F;&#x2F; Create a uniswap pair for this new token\n        uniswapV2Pair &#x3D; IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n \n        &#x2F;&#x2F; set the rest of the contract variables\n        uniswapV2Router &#x3D; _uniswapV2Router;\n        \n        &#x2F;&#x2F;exclude owner and this contract from fee\n        _isExcludedFromFee[owner()] &#x3D; true;\n        _isExcludedFromFee[address(this)] &#x3D; true;\n        \n        emit Transfer(address(0), _msgSender(), _tTotal);\n    &#125;\n\n\n首先把所有代币设置给合约的部署者，然后通过UniswapV2Router02创建一个交易对，最后将本合约地址和部署者设置成白名单，他们转账不需要收手续费。\n4、核心方法4.1 _transferfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private &#123;\n        require(from !&#x3D; address(0), &quot;ERC20: transfer from the zero address&quot;);\n        require(to !&#x3D; address(0), &quot;ERC20: transfer to the zero address&quot;);\n        require(amount &gt; 0, &quot;Transfer amount must be greater than zero&quot;);\n        if(from !&#x3D; owner() &amp;&amp; to !&#x3D; owner())\n            require(amount &lt;&#x3D; _maxTxAmount, &quot;Transfer amount exceeds the maxTxAmount.&quot;);\n \n        &#x2F;&#x2F; is the token balance of this contract address over the min number of\n        &#x2F;&#x2F; tokens that we need to initiate a swap + liquidity lock?\n        &#x2F;&#x2F; also, don&#39;t get caught in a circular liquidity event.\n        &#x2F;&#x2F; also, don&#39;t swap &amp; liquify if sender is uniswap pair.\n        uint256 contractTokenBalance &#x3D; balanceOf(address(this));\n        \n        if(contractTokenBalance &gt;&#x3D; _maxTxAmount)\n        &#123;\n            contractTokenBalance &#x3D; _maxTxAmount;\n        &#125;\n        \n        bool overMinTokenBalance &#x3D; contractTokenBalance &gt;&#x3D; numTokensSellToAddToLiquidity;\n        if (\n            overMinTokenBalance &amp;&amp;\n            !inSwapAndLiquify &amp;&amp;\n            from !&#x3D; uniswapV2Pair &amp;&amp;\n            swapAndLiquifyEnabled\n        ) &#123;\n            contractTokenBalance &#x3D; numTokensSellToAddToLiquidity;\n            &#x2F;&#x2F;add liquidity\n            swapAndLiquify(contractTokenBalance);\n        &#125;\n        \n        &#x2F;&#x2F;indicates if fee should be deducted from transfer\n        bool takeFee &#x3D; true;\n        \n        &#x2F;&#x2F;if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to])&#123;\n            takeFee &#x3D; false;\n        &#125;\n        \n        &#x2F;&#x2F;transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from,to,amount,takeFee);\n    &#125;\n    \n这个函数首先校验转账账号以及转账金额，然后获取当前合约的safemoon余额，如果大于numTokensSellToAddToLiquidity并且转账发起人不是uniswap的交易对，并且当前允许添加流动性，接下来就会进入添加流动性的流程。添加完流动性后，进入_tokenTransfer方法继续执行转账。\n4.2.swapAndLiquifyfunction swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap &#123;\n        &#x2F;&#x2F; split the contract balance into halves\n        uint256 half &#x3D; contractTokenBalance.div(2);\n        uint256 otherHalf &#x3D; contractTokenBalance.sub(half);\n \n        &#x2F;&#x2F; capture the contract&#39;s current ETH balance.\n        &#x2F;&#x2F; this is so that we can capture exactly the amount of ETH that the\n        &#x2F;&#x2F; swap creates, and not make the liquidity event include any ETH that\n        &#x2F;&#x2F; has been manually sent to the contract\n        uint256 initialBalance &#x3D; address(this).balance;\n \n        &#x2F;&#x2F; swap tokens for ETH\n        swapTokensForEth(half); &#x2F;&#x2F; &lt;- this breaks the ETH -&gt; HATE swap when swap+liquify is triggered\n \n        &#x2F;&#x2F; how much ETH did we just swap into?\n        uint256 newBalance &#x3D; address(this).balance.sub(initialBalance);\n \n        &#x2F;&#x2F; add liquidity to uniswap\n        addLiquidity(otherHalf, newBalance);\n        \n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    &#125;\n\n\n这个函数用于添加流动性。首先将传入的数量对半分，然后记录当前合约的ETH数量，然后调用swapTokensForEth将一半的safemoon转换成ETH，通过最新余额和原来的余额，计算出这次swap的ETH数量newBalance，最后调用addLiquidity添加流动性（Safemonn-ETH币对）。\n4.3 swapTokensForEthfunction swapTokensForEth(uint256 tokenAmount) private &#123;\n        &#x2F;&#x2F; generate the uniswap pair path of token -&gt; weth\n        address[] memory path &#x3D; new address[](2);\n        path[0] &#x3D; address(this);\n        path[1] &#x3D; uniswapV2Router.WETH();\n \n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n \n        &#x2F;&#x2F; make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, &#x2F;&#x2F; accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n    &#125;\n\n首先构建一个交易路径：[Safemonn ,uniswapV2Router.WETH()]，然后授权给uniswapV2Router一定额度，最终调用uniswapV2Router的swapExactTokensForETHSupportingFeeOnTransferTokens方法执行兑换。注意，这里必须使用swapExactTokensForETHSupportingFeeOnTransferTokens这个方法，因为执行兑换的时候会执行transfer会收手续费，这个方法是uniswap专门给有手续费的币开发的。\n4.4 addLiquidityfunction addLiquidity(uint256 tokenAmount, uint256 ethAmount) private &#123;\n        &#x2F;&#x2F; approve token transfer to cover all possible scenarios\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n \n        &#x2F;&#x2F; add the liquidity\n        uniswapV2Router.addLiquidityETH&#123;value: ethAmount&#125;(\n            address(this),\n            tokenAmount,\n            0, &#x2F;&#x2F; slippage is unavoidable\n            0, &#x2F;&#x2F; slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n    &#125;\n这个方法用于添加流动性，添加流动性本质是将Safemoon和ETH都转给uniswapV2Router，然后获得流动性代币的过程。这里首先授权uniswapV2Router一定的Safemoon额度，然后调用 uniswapV2Router.addLiquidityETH添加流动性。\n4.5 _tokenTransferfunction _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private &#123;\n        if(!takeFee)\n            removeAllFee();\n        \n        if (_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n            _transferFromExcluded(sender, recipient, amount);\n        &#125; else if (!_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n            _transferToExcluded(sender, recipient, amount);\n        &#125; else if (!_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n            _transferStandard(sender, recipient, amount);\n        &#125; else if (_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n            _transferBothExcluded(sender, recipient, amount);\n        &#125; else &#123;\n            _transferStandard(sender, recipient, amount);\n        &#125;\n        \n        if(!takeFee)\n            restoreAllFee();\n    &#125;\n这个方法是实际的转账，如果takeFee为false，也就是不收手续费，首先会通过removeAllFee将手续费相关参数置零，最后通过restoreAllFee恢复。中间部分根据是否参与分红，分成四种情况：\n\n1、sender和recipient都不参加分红，这时候走_transferBothExcluded\n\n2、sender不参加，recipient参加，这时候走_transferFromExcluded\n\n3、sender参加，recipient不参加，这时候走_transferToExcluded\n\n4、都参加，这时候走_transferStandard，默认用户都走这个\nfunction _transferBothExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getValues(tAmount);\n        _tOwned[sender] &#x3D; _tOwned[sender].sub(tAmount);\n        _rOwned[sender] &#x3D; _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] &#x3D; _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] &#x3D; _rOwned[recipient].add(rTransferAmount);        \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);&#125;\n    \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getValues(tAmount);\n        _rOwned[sender] &#x3D; _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] &#x3D; _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n \n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getValues(tAmount);\n        _rOwned[sender] &#x3D; _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] &#x3D; _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] &#x3D; _rOwned[recipient].add(rTransferAmount);           \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n \n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getValues(tAmount);\n        _tOwned[sender] &#x3D; _tOwned[sender].sub(tAmount);\n        _rOwned[sender] &#x3D; _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] &#x3D; _rOwned[recipient].add(rTransferAmount);   \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n这四个transfer方法首先都会通过_getValues获取本次转账的参数，然后进行t值和r值的加减。然后扣除转账手续费和流动性手续费。\nfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) &#123;\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) &#x3D; _getRValues(tAmount, tFee, tLiquidity, _getRate());\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n    &#125;\n \n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) &#123;\n        uint256 tFee &#x3D; calculateTaxFee(tAmount);\n        uint256 tLiquidity &#x3D; calculateLiquidityFee(tAmount);\n        uint256 tTransferAmount &#x3D; tAmount.sub(tFee).sub(tLiquidity);\n        return (tTransferAmount, tFee, tLiquidity);\n    &#125;\n \n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) &#123;\n        uint256 rAmount &#x3D; tAmount.mul(currentRate);\n        uint256 rFee &#x3D; tFee.mul(currentRate);\n        uint256 rLiquidity &#x3D; tLiquidity.mul(currentRate);\n        uint256 rTransferAmount &#x3D; rAmount.sub(rFee).sub(rLiquidity);\n        return (rAmount, rTransferAmount, rFee);\n    &#125;\n    \n    function _getRate() private view returns(uint256) &#123;\n        (uint256 rSupply, uint256 tSupply) &#x3D; _getCurrentSupply();\n        return rSupply.div(tSupply);\n    &#125;\n \n    function _getCurrentSupply() private view returns(uint256, uint256) &#123;\n        uint256 rSupply &#x3D; _rTotal;\n        uint256 tSupply &#x3D; _tTotal;      \n        for (uint256 i &#x3D; 0; i &lt; _excluded.length; i++) &#123;\n            if (_rOwned[_excluded[i]] &gt; rSupply || _tOwned[_excluded[i]] &gt; tSupply) return (_rTotal, _tTotal);\n            rSupply &#x3D; rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply &#x3D; tSupply.sub(_tOwned[_excluded[i]]);\n        &#125;\n        if (rSupply &lt; _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    &#125;\n    \n    function calculateTaxFee(uint256 _amount) private view returns (uint256) &#123;\n        return _amount.mul(_taxFee).div(\n            10**2\n        );\n    &#125;\n \n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) &#123;\n        return _amount.mul(_liquidityFee).div(\n            10**2\n        );\n    &#125;\n    \n    function _reflectFee(uint256 rFee, uint256 tFee) private &#123;\n        _rTotal &#x3D; _rTotal.sub(rFee);\n        _tFeeTotal &#x3D; _tFeeTotal.add(tFee);\n    &#125;\n    \n    function _takeLiquidity(uint256 tLiquidity) private &#123;\n        uint256 currentRate &#x3D;  _getRate();\n        uint256 rLiquidity &#x3D; tLiquidity.mul(currentRate);\n        _rOwned[address(this)] &#x3D; _rOwned[address(this)].add(rLiquidity);\n        if(_isExcluded[address(this)])\n            _tOwned[address(this)] &#x3D; _tOwned[address(this)].add(tLiquidity);\n    &#125;\n    \n    function balanceOf(address account) public view override returns (uint256) &#123;\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    &#125;\n    \n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) &#123;\n        require(rAmount &lt;&#x3D; _rTotal, &quot;Amount must be less than total reflections&quot;);\n        uint256 currentRate &#x3D;  _getRate();\n        return rAmount.div(currentRate);\n    &#125;\n_getValues先获取t值，再获取r值。普通分红用户只会用到r值，这个值其实就是用户的盘子数量，t值永远是0。而不参与分红的用户，除了r值正常变化，t值也会变化，如果别人转给他，t值就增加，如果他转给别人t值就减少。普通分红用户t值为0，当管理员把用户设置为非分红用户的时候，t值会通过用户当前的r值进行换算，而再次设置为分红用户的时候，t值又会清零。通过t值和r值的分离，实现了分红用户和非分红用户的分离。\n\n\n在执行transfer的时候，会调用_reflectFee，这个会减少_rTotal，也就是打碎一些盘子的数量。也会调用_takeLiquidity，这个是转移流动性手续费，仅仅是盘子的转移，不会打碎盘子。\n而balanceOf的实现如下：rAmount.div(rSupply.div(tSupply)) ====&gt; rAmount * tSupply / rSupply\ntSupply是排除非分红的用户的总蛋糕数，rSupply是排除非分红用户的总盘子数，当全是分红用户的时候，tSupply就是_tTotal，rSupply就是_rTotal。\n当别人转账的时候打碎了一部分盘子，这导致rSupply减少，而总蛋糕tSupply不变，用户自己持有的盘子rAmount也不变，这样就导致自己分到的蛋糕总量增加了，这就是分红的原理。\n5、通缩分红币的潜在问题\n由于每次转账都会销毁手续费，当剩余总量小于手续费得时候，就无法转账了。\n\n这种币把balanceOf的逻辑改了，导致即使用户不进行任何操作，balanceOf在不同时刻返回的值是不一样的。这在一些强依赖balanceOf的的合约中就会出现问题，比如sushiswap如果使用通缩币进行质押，就可能导致计算奖励出现问题。因此，智能合约开发者在进行开发的时候，需要考虑下通缩币的逻辑，避免出现不必要的漏洞。\n\n这个币强依赖uniswap，一旦uniswap升级或者下线，该币可能会受到影响。\n\n\n","slug":"通缩分红币Safemoon解读/index","date":"2022-03-18T16:01:39.000Z","categories_index":"Solidity","tags_index":"区块链,Solidity,智能合约","author_index":"Bug Designer"},{"id":"bb3bf222bcca42dfaadd6e15dbdfbacd","title":"详解分红其他代币，添加流动性合约","content":"contract Token is ERC20, Ownable &#123;\n    using SafeMath for uint256;\n \n    IUniswapV2Router02 public uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    bool private swapping;\n    bool public swapEnabled &#x3D; true;\n    DividendTracker public dividendTracker;          &#x2F;&#x2F;分红对象\n    address public liquidityWallet;          &#x2F;&#x2F;流动性钱包\n    address private _marketingWalletAddress;         &#x2F;&#x2F;营销钱包，收手续费的\n    address public deadWallet &#x3D; 0x000000000000000000000000000000000000dEaD;        &#x2F;&#x2F;销毁钱包，也就是把钱打进这里。\n    uint256 public maxSellTransactionAmount &#x3D; 10000000000000 * (10 ** 16);              &#x2F;&#x2F;最大卖出数量\n    uint256 public swapTokensAtAmount &#x3D; 1000000000 * (10 ** 18);                      \n    uint256  BNBRewardsFee &#x3D; 7;                                                     &#x2F;&#x2F;分红每次交易百分之7的bnb\n    uint256  liquidityFee &#x3D; 3;                                                      &#x2F;&#x2F;流动性手续费\n    uint256  marketingFee &#x3D; 4;                                                       &#x2F;&#x2F;营销钱包收进的手续费\n \n    uint256 public totalFees &#x3D; BNBRewardsFee.add(liquidityFee).add(marketingFee);               &#x2F;&#x2F;总手续费用\n    uint256 public tradingEnabledTimestamp &#x3D; 1628258400; &#x2F;&#x2F;10:00pm                     &#x2F;&#x2F;2021-08-06 22:00:00的时间戳          \n \n    &#x2F;&#x2F; sells have fees of 12 and 6 (10 * 1.2 and 5 * 1.2)           \n    uint256 public immutable sellFeeIncreaseFactor &#x3D; 120;\n \n    &#x2F;&#x2F; use by default 300,000 gas to process auto-claiming dividends\n    &#x2F;&#x2F;默认使用300000 gas 处理自动申请分红\n    uint256 public gasForProcessing &#x3D; 300000;\n \n    mapping(address &#x3D;&gt; bool) private _isExcludedFromFees;          &#x2F;&#x2F;判断是否此账号需要手续费，true为不需要手续费\n    mapping(address &#x3D;&gt; bool) public automatedMarketMakerPairs;        &#x2F;&#x2F;判断是否卖出\n    mapping(address &#x3D;&gt; bool) public _isBlacklisted;    &#x2F;&#x2F;是否是黑名单,true表示这个地址是黑名单\n \n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);     &#x2F;&#x2F;监听更新分红跟踪事件\n \n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);            &#x2F;&#x2F;监听更新周边路由事件\n \n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\n \n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n \n    event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);\n \n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n \n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n    );\n \n    event SendDividends(\n        uint256 tokensSwapped,\n        uint256 amount\n    );\n \n    event ProcessedDividendTracker(\n        uint256 iterations,\n        uint256 claims,\n        uint256 lastProcessedIndex,\n        bool indexed automatic,\n        uint256 gas,\n        address indexed processor\n    );\n \n    constructor(address _ma) public ERC20(&quot;man&quot;, &quot;man&quot;) &#123;\n \n        dividendTracker &#x3D; new DividendTracker();   \n \n        liquidityWallet &#x3D; owner();          &#x2F;&#x2F;流动性钱包&#x3D;msg.sender.也就是部署这个合约的钱包\n        _marketingWalletAddress &#x3D; _ma;          &#x2F;&#x2F;营销钱包&#x3D;_ma\n        \n        IUniswapV2Router02 _uniswapV2Router &#x3D; IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);  &#x2F;&#x2F;构造测试网的_uniswapV2Router对象\n        &#x2F;&#x2F; Create a uniswap pair for this new token\n        &#x2F;&#x2F;为这个新币创建一个uniswap pair  也就是uniswap的核心合约\n        address _uniswapV2Pair &#x3D; IUniswapV2Factory(_uniswapV2Router.factory())     &#x2F;&#x2F;factory 返回地址也就是0x9Ac64那个\n        .createPair(address(this), _uniswapV2Router.WETH());   &#x2F;&#x2F;createPair创建交易对 .该函数接受任意两个代币地址为参数，用来创建一个新的交易对合约并返回新合约的地址。\n        &#x2F;&#x2F;createPair的第一个地址是这个合约的地址，第二个地址是0x9Ac64Cc6e地址\n        uniswapV2Router &#x3D; _uniswapV2Router;     \n        uniswapV2Pair &#x3D; _uniswapV2Pair;\n \n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\n \n        &#x2F;&#x2F; exclude from receiving dividends  不在分红范围内的\n        dividendTracker.excludeFromDividends(address(dividendTracker));            \n        dividendTracker.excludeFromDividends(address(this));                 &#x2F;&#x2F;这个合约地址\n        dividendTracker.excludeFromDividends(owner());                        &#x2F;&#x2F;msg.sender地址,也就铸币接收者\n        dividendTracker.excludeFromDividends(deadWallet);                     &#x2F;&#x2F;销毁地址\n        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\n \n        &#x2F;&#x2F; exclude from paying fees or having max transaction amount 排除支付费用或拥有最大交易金额\n        excludeFromFees(liquidityWallet, true);        &#x2F;&#x2F;排除流动性钱包的支付手续费和最大交易金额\n        excludeFromFees(address(this), true);              &#x2F;&#x2F;排除铸币钱包的支付手续费和最大交易金额\n        excludeFromFees(_marketingWalletAddress, true);      &#x2F;&#x2F;排除营销钱包的支付手续费和最大交易金额\n \n        _mint(owner(), 10000000000000 * (10 ** 18));            &#x2F;&#x2F;铸币给msg.ssender于10000000000000个币；\n    &#125;                  \n    &#x2F;&#x2F;外部合约调用接收方法\n    receive() external payable &#123;\n \n    &#125;\n    &#x2F;&#x2F;改变最大卖出额度\n    function changeMaxSellTransactionAmount(uint amount) external onlyOwner &#123;\n        maxSellTransactionAmount &#x3D; amount;\n    &#125;\n    &#x2F;&#x2F;更新分红合约对象\n    function updateDividendTracker(address newAddress) public onlyOwner &#123;\n        &#x2F;&#x2F;如果新地址&#x3D;&#x3D;adaddress(ddividendTracker)则跳出函数\n        require(newAddress !&#x3D; address(dividendTracker), &quot;RedCheCoin The dividend tracker already has that address&quot;);\n        \n        DividendTracker newDividendTracker &#x3D; DividendTracker(payable(newAddress));\n \n        require(newDividendTracker.owner() &#x3D;&#x3D; address(this), &quot;RedCheCoin The new dividend tracker must be owned by the RedCheCoin token contract&quot;);\n \n        newDividendTracker.excludeFromDividends(address(newDividendTracker));       &#x2F;&#x2F;newDividendTracker地址不分红\n        newDividendTracker.excludeFromDividends(address(this));                    &#x2F;&#x2F;这个合约地址不分红\n        newDividendTracker.excludeFromDividends(owner());                           &#x2F;&#x2F;msg.sender地址\n        newDividendTracker.excludeFromDividends(address(uniswapV2Router));          &#x2F;&#x2F;代币对地址\n \n        emit UpdateDividendTracker(newAddress, address(dividendTracker));   \n \n        dividendTracker &#x3D; newDividendTracker;                     \n    &#125;\n    &#x2F;&#x2F;更新周边路由事件\n    function updateUniswapV2Router(address newAddress) public onlyOwner &#123;\n        require(newAddress !&#x3D; address(uniswapV2Router), &quot;RedCheCoin The router already has that address&quot;);  &#x2F;&#x2F;如果新的地址是原来的周边路由地址则跳出\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));         \n        uniswapV2Router &#x3D; IUniswapV2Router02(newAddress);      &#x2F;&#x2F;把新的周边路由地址赋值给旧的\n    &#125;\n    &#x2F;&#x2F;排除手续费\n    function excludeFromFees(address account, bool excluded) public onlyOwner &#123;   &#x2F;&#x2F;onlyOwner判断是不是msg.sender\n        require(_isExcludedFromFees[account] !&#x3D; excluded, &quot;RedCheCoin Account is already the value of &#39;excluded&#39;&quot;);   &#x2F;&#x2F;如果已经排除就跳出\n        _isExcludedFromFees[account] &#x3D; excluded;                 &#x2F;&#x2F;设置是否排除的布尔值\n \n        emit ExcludeFromFees(account, excluded);\n    &#125;\n    &#x2F;&#x2F;排除多个地址账号的手续费\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner &#123;\n        for (uint256 i &#x3D; 0; i &lt; accounts.length; i++) &#123;\n            _isExcludedFromFees[accounts[i]] &#x3D; excluded;\n        &#125;\n \n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\n    &#125;\n    &#x2F;&#x2F;设置lp流动性地址\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner &#123;\n        require(pair !&#x3D; uniswapV2Pair, &quot;RedCheCoin The PancakeSwap pair cannot be removed from automatedMarketMakerPairs&quot;);\n        \n        _setAutomatedMarketMakerPair(pair, value);\n    &#125;\n    &#x2F;&#x2F;设置黑名单地址\n    function blacklistAddress(address account, bool value) external onlyOwner &#123;\n        _isBlacklisted[account] &#x3D; value;   &#x2F;&#x2F;如果是true就是黑名单\n    &#125;\n \n    function _setAutomatedMarketMakerPair(address pair, bool value) private &#123;\n        &#x2F;&#x2F;做一个判断如果已经赋了布尔值就跳出函数\n        require(automatedMarketMakerPairs[pair] !&#x3D; value, &quot;RedCheCoin Automated market maker pair is already set to that value&quot;);\n        automatedMarketMakerPairs[pair] &#x3D; value;     \n        if (value) &#123;\n            dividendTracker.excludeFromDividends(pair);\n        &#125;\n \n        emit SetAutomatedMarketMakerPair(pair, value);\n    &#125;\n \n    &#x2F;&#x2F;更新流动池钱包\n    function updateLiquidityWallet(address newLiquidityWallet) public onlyOwner &#123;\n        require(newLiquidityWallet !&#x3D; liquidityWallet, &quot;RedCheCoin The liquidity wallet is already this address&quot;);\n        _isExcludedFromFees[newLiquidityWallet] &#x3D; true;          &#x2F;&#x2F;设置新的流动池钱包\n        emit LiquidityWalletUpdated(newLiquidityWallet, liquidityWallet);        \n        liquidityWallet &#x3D; newLiquidityWallet;          &#x2F;&#x2F;旧流动池钱包&#x3D;新流动池钱包             \n    &#125;\n    &#x2F;&#x2F;更新营销钱包\n    function updateMarketingWallet(address newMarkting) public onlyOwner &#123;\n        require(newMarkting !&#x3D; _marketingWalletAddress, &quot;RedCheCoin The Markting wallet is already this address&quot;);  &#x2F;&#x2F;如果新营销钱包&#x3D;旧营销钱包则跳出\n        _isExcludedFromFees[newMarkting] &#x3D; true;                                                    &#x2F;&#x2F;设置新营销钱包除外手续费\n        _marketingWalletAddress &#x3D; newMarkting;                                                       &#x2F;&#x2F;旧营销钱包&#x3D;新营销钱包\n    &#125;\n    &#x2F;&#x2F;更新gas费用\n    function updateGasForProcessing(uint256 newValue) public onlyOwner &#123;\n        require(newValue &gt;&#x3D; 200000 &amp;&amp; newValue &lt;&#x3D; 500000, &quot;RedCheCoin gasForProcessing must be between 200,000 and 500,000&quot;);    &#x2F;&#x2F;非200000到500000则跳出\n        require(newValue !&#x3D; gasForProcessing, &quot;RedCheCoin Cannot update gasForProcessing to same value&quot;);       &#x2F;&#x2F;如果和旧的值一样就跳出\n        emit GasForProcessingUpdated(newValue, gasForProcessing);   \n        gasForProcessing &#x3D; newValue;                                      &#x2F;&#x2F;旧的gas&#x3D;新的gas\n    &#125;\n    \n    function updateClaimWait(uint256 claimWait) external onlyOwner &#123;\n        dividendTracker.updateClaimWait(claimWait);\n    &#125;\n \n    function getClaimWait() external view returns (uint256) &#123;\n        return dividendTracker.claimWait();\n    &#125;\n \n    function getTotalDividendsDistributed() external view returns (uint256) &#123;\n        return dividendTracker.totalDividendsDistributed();\n    &#125;\n    &#x2F;&#x2F;block.timestamp (uint):当前块的时间戳\n    &#x2F;&#x2F;此函数通过到达开盘时间才能交易\n    function getTradingIsEnabled() public view returns (bool) &#123;\n        return block.timestamp &gt;&#x3D; tradingEnabledTimestamp;\n    &#125;\n    &#x2F;&#x2F;返回是否除外手续费的布尔值\n    function isExcludedFromFees(address account) public view returns (bool) &#123;\n        return _isExcludedFromFees[account];\n    &#125;\n    &#x2F;&#x2F;应该是取回分红？？？\n    function withdrawableDividendOf(address account) public view returns (uint256) &#123;\n        return dividendTracker.withdrawableDividendOf(account);\n    &#125;\n    &#x2F;&#x2F;取的分红的地址\n    function dividendTokenBalanceOf(address account) public view returns (uint256) &#123;\n        return dividendTracker.balanceOf(account);\n    &#125;\n    \n    function getAccountDividendsInfo(address account)\n    external view returns (\n        address,\n        int256,\n        int256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256) &#123;\n        return dividendTracker.getAccount(account);\n    &#125;\n \n    function getAccountDividendsInfoAtIndex(uint256 index)\n    external view returns (\n        address,\n        int256,\n        int256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256) &#123;\n        return dividendTracker.getAccountAtIndex(index);\n    &#125;\n \n    function processDividendTracker(uint256 gas) external &#123;\n        (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) &#x3D; dividendTracker.process(gas);\n        emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\n    &#125;\n \n    function claim() external &#123;\n        dividendTracker.processAccount(msg.sender, false);\n    &#125;\n \n    function getLastProcessedIndex() external view returns (uint256) &#123;\n        return dividendTracker.getLastProcessedIndex();\n    &#125;\n \n    function getNumberOfDividendTokenHolders() external view returns (uint256) &#123;\n        return dividendTracker.getNumberOfTokenHolders();\n    &#125;\n    &#x2F;&#x2F;交易函数\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override &#123;\n        require(from !&#x3D; address(0), &quot;ERC20: transfer from the zero address&quot;);    &#x2F;&#x2F;如果发送方是空地址则跳出\n        require(!_isBlacklisted[from], &#39;Blacklisted address&#39;);                        &#x2F;&#x2F;如果接收方是空地址则跳出\n \n \n        if (amount &#x3D;&#x3D; 0) &#123;                              &#x2F;&#x2F;转0个币则直接转\n            super._transfer(from, to, 0);\n            return;\n        &#125;\n \n        if (swapping) &#123;\n            super._transfer(from, to, amount);\n            return;\n        &#125;\n \n        bool isMng &#x3D; _isExcludedFromFees[from] || _isExcludedFromFees[to];      &#x2F;&#x2F;判断是否非手续费\n        bool tradingIsEnabled &#x3D; getTradingIsEnabled();               &#x2F;&#x2F;判断是到开盘时间，true表示到了          \n \n        &#x2F;&#x2F; add liqiud\n        if (!tradingIsEnabled) &#123;                  &#x2F;&#x2F;判断是否到开盘时间\n            require(isMng, &quot;This account cannot send tokens until trading is enabled&quot;);   &#x2F;&#x2F;判断是否添加流动池账号，如果不是则跳出此函数\n        &#125;\n \n        if (\n            tradingIsEnabled &amp;&amp;                  &#x2F;&#x2F;到达开盘时间\n            balanceOf(uniswapV2Pair) &gt; 0 &amp;&amp;                 &#x2F;&#x2F;流动池大于0\n            automatedMarketMakerPairs[from] &amp;&amp;         &#x2F;&#x2F;li流动性可用          \n            !isMng &amp;&amp;                           &#x2F;&#x2F;是否排除手续费\n            tradingIsEnabled &amp;&amp;                         \n            block.timestamp &lt;&#x3D; tradingEnabledTimestamp + 9 seconds) &#123;  &#x2F;&#x2F;当前块的时间戳小于等于 可交易时间戳+9秒。如果是在9秒内抢到\n            addBot(to);                                 &#x2F;&#x2F;则添加黑名单\n        &#125;\n \n        if (\n            !swapping &amp;&amp;                        \n        from !&#x3D; address(uniswapV2Router) &amp;&amp;\n        to !&#x3D; address(uniswapV2Router) &amp;&amp;\n        !isMng\n        ) &#123;\n            require(amount &lt;&#x3D; maxSellTransactionAmount, &quot;Sell transfer amount exceeds the maxSellTransactionAmount.&quot;);  &#x2F;&#x2F;判断是否超出最大可卖出数量\n        &#125;\n \n        uint256 contractTokenBalance &#x3D; balanceOf(address(this));          &#x2F;&#x2F;获得该代币余额\n \n        bool canSwap &#x3D; contractTokenBalance &gt;&#x3D; swapTokensAtAmount;        &#x2F;&#x2F;是否可以交易\n \n        if (\n            swapEnabled &amp;&amp;\n            canSwap &amp;&amp;\n            !swapping &amp;&amp;\n            !automatedMarketMakerPairs[from] &amp;&amp;\n            from !&#x3D; liquidityWallet &amp;&amp;\n            to !&#x3D; liquidityWallet\n        ) &#123;\n            swapping &#x3D; true;\n \n            uint256 marketingTokens &#x3D; contractTokenBalance.mul(marketingFee).div(totalFees);    &#x2F;&#x2F;营销钱包的币&#x3D;该合约代币余额*营销手续费&#x2F;总手续费\n            swapAndSendToFee(marketingTokens);                                          &#x2F;&#x2F;发送给营销钱包手续费用的币\n \n            uint256 swapTokens &#x3D; contractTokenBalance.mul(liquidityFee).div(totalFees);               &#x2F;&#x2F;添加流动性的币&#x3D;该合约代币余额*流动性手续费&#x2F;总手续费\n            swapAndLiquify(swapTokens);                                    &#x2F;&#x2F;添加流动性\n \n            uint256 sellTokens &#x3D; balanceOf(address(this));                                &#x2F;&#x2F;卖的币&#x3D;该合约代币余额\n            swapAndSendDividends(sellTokens);                                           &#x2F;&#x2F;分红卖的币\n            swapping &#x3D; false;\n        &#125;\n \n \n        bool takeFee &#x3D; !swapping;                   \n \n        &#x2F;&#x2F; if any account belongs to _isExcludedFromFee account then remove the fee 如果任何帐户属于_isExcludedFromFee帐户，那么删除费用\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) &#123;\n            takeFee &#x3D; false;                                   &#x2F;&#x2F;设置无手续费\n        &#125;\n \n        if (takeFee) &#123;\n            uint256 fees &#x3D; amount.mul(totalFees).div(100);           &#x2F;&#x2F;手续费&#x3D;币数量*总手续费&#x2F;100;\n \n            &#x2F;&#x2F; if sell, multiply by 1.2\n            if (automatedMarketMakerPairs[to]) &#123;\n                fees &#x3D; fees.mul(sellFeeIncreaseFactor).div(100);            &#x2F;&#x2F;如果卖出的话手续费*1.2\n            &#125;\n \n            amount &#x3D; amount.sub(fees);             &#x2F;&#x2F;币数量&#x3D;币数量-手续费\n \n            super._transfer(from, address(this), fees);            &#x2F;&#x2F;转账msg.sender到合约地址，手续费用的币\n        &#125;\n \n        super._transfer(from, to, amount);                  &#x2F;&#x2F;转账实际已经扣除手续的币\n \n        try dividendTracker.setBalance(payable(from), balanceOf(from)) &#123;&#125; catch &#123;&#125;\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) &#123;&#125; catch &#123;&#125;\n \n        if (!swapping) &#123;\n            uint256 gas &#x3D; gasForProcessing;       \n \n            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) &#123;\n                emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\n            &#125;\n            catch &#123;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;设置是否可交易\n    function setSwapEnabled(bool _enabled) external onlyOwner &#123;\n        swapEnabled &#x3D; _enabled;\n    &#125;\n    &#x2F;&#x2F;设置手续费用\n    function setF(uint _BNBRewardsFee, uint _liquidityFee, uint _marketingFee) external onlyOwner &#123;\n        BNBRewardsFee &#x3D; _BNBRewardsFee;\n        liquidityFee &#x3D; _liquidityFee;\n        marketingFee &#x3D; _marketingFee;\n    &#125;\n    &#x2F;&#x2F;添加黑名单的函数\n    function addBot(address recipient) private &#123;\n        if (!_isBlacklisted[recipient]) _isBlacklisted[recipient] &#x3D; true;\n    &#125;\n    &#x2F;&#x2F;发送给营销钱包手续费用\n    function swapAndSendToFee(uint256 tokens) private &#123;\n        uint256 initialBNBBalance &#x3D; address(this).balance;\n        swapTokensForEth(tokens);   \n        uint256 newBalance &#x3D; address(this).balance.sub(initialBNBBalance);\n        payable(_marketingWalletAddress).transfer(newBalance);\n    &#125;\n    &#x2F;&#x2F;交易流动性\n    function swapAndLiquify(uint256 tokens) private &#123;\n        &#x2F;&#x2F; split the contract balance into halves 把该合同余额平分，分成一半\n        uint256 half &#x3D; tokens.div(2);\n        uint256 otherHalf &#x3D; tokens.sub(half);\n \n        &#x2F;&#x2F; capture the contract&#39;s current ETH balance.   获取合同当前ETH余额。\n        &#x2F;&#x2F; this is so that we can capture exactly the amount of ETH that the   这样我们就能准确地捕获ETH的数量\n        &#x2F;&#x2F; swap creates, and not make the liquidity event include any ETH that    交换产生，而不使流动性事件包括任何ETH\n        &#x2F;&#x2F; has been manually sent to the contract    手动发送给合约地址\n        uint256 initialBalance &#x3D; address(this).balance;\n \n        &#x2F;&#x2F; swap tokens for ETH  ETH交换代币\n        swapTokensForEth(half);\n        &#x2F;&#x2F; &lt;- this breaks the ETH -&gt; HATE swap when swap+liquify is triggered  当swap+liquify被触发时，这会打破ETH -&gt;HATE swap\n \n        &#x2F;&#x2F; how much ETH did we just swap into?   我们刚才换了多少ETH ?\n        uint256 newBalance &#x3D; address(this).balance.sub(initialBalance);\n \n        &#x2F;&#x2F; add liquidity to uniswap      为uniswap增加流动性\n        addLiquidity(otherHalf, newBalance);\n \n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    &#125;\n    &#x2F;&#x2F;交换代币\n    function swapTokensForEth(uint256 tokenAmount) private &#123;\n \n \n        &#x2F;&#x2F; generate the uniswap pair path of token -&gt; weth  生成unswap pair周边合约代币路径 -&gt; 用eth位来表示\n        address[] memory path &#x3D; new address[](2);   \n        path[0] &#x3D; address(this);\n        path[1] &#x3D; uniswapV2Router.WETH();\n \n        _approve(address(this), address(uniswapV2Router), tokenAmount);    \n \n        &#x2F;&#x2F; make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, &#x2F;&#x2F; accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n \n    &#125;\n    &#x2F;&#x2F;添加流动性\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private &#123;\n \n        &#x2F;&#x2F; approve token transfer to cover all possible scenarios      批准代币转账以覆盖所有可能的场景\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n \n        &#x2F;&#x2F; add the liquidity           添加流动性\n        uniswapV2Router.addLiquidityETH&#123;value : ethAmount&#125;(\n            address(this),\n            tokenAmount,\n            0, &#x2F;&#x2F; slippage is unavoidable     &#x2F;&#x2F;滑点是不可避免的\n            0, &#x2F;&#x2F; slippage is unavoidable   &#x2F;&#x2F;滑点是不可避免的\n            liquidityWallet,                     &#x2F;&#x2F;流动性钱包;\n            block.timestamp                  &#x2F;&#x2F;当块的时间戳\n        );\n \n    &#125;\n    &#x2F;&#x2F;交易分红\n    function swapAndSendDividends(uint256 tokens) private &#123;\n        swapTokensForEth(tokens);\n        uint256 dividends &#x3D; address(this).balance;\n        (bool success,) &#x3D; address(dividendTracker).call&#123;value : dividends&#125;(&quot;&quot;);\n \n        if (success) &#123;\n            emit SendDividends(tokens, dividends);\n        &#125;\n    &#125;\n&#125;\n\n发射器合约\n&#x2F;&#x2F; SPDX-License-Identifier: MIT\n \npragma solidity ^0.6.2;\nimport &quot;.&#x2F;Ownable.sol&quot;;\nimport &quot;.&#x2F;DividendPayingToken.sol&quot;;\nimport &quot;.&#x2F;SafeMath.sol&quot;;\nimport &quot;.&#x2F;SafeMathInt.sol&quot;;\nimport &quot;.&#x2F;IterableMapping.sol&quot;;\ncontract DividendTracker is Ownable, DividendPayingToken &#123;\n    using SafeMath for uint256;\n    using SafeMathInt for int256;\n    using IterableMapping for IterableMapping.Map;\n \n    IterableMapping.Map private tokenHoldersMap;\n    uint256 public lastProcessedIndex;\n \n    mapping(address &#x3D;&gt; bool) public excludedFromDividends;\n \n    mapping(address &#x3D;&gt; uint256) public lastClaimTimes;\n \n    uint256 public claimWait;\n    uint256 public immutable minimumTokenBalanceForDividends;\n \n    event ExcludeFromDividends(address indexed account);\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n \n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\n \n    constructor() public DividendPayingToken(&quot;RedCheCoin_Dividend_Tracker&quot;, &quot;RedCheCoin_Dividend_Tracker&quot;) &#123;\n        claimWait &#x3D; 1200;\n        minimumTokenBalanceForDividends &#x3D; 10000 * (10 ** 18);\n        &#x2F;&#x2F;must hold 10000+ tokens\n    &#125;\n \n    function _transfer(address, address, uint256) internal override &#123;\n        require(false, &quot;RedCheCoin_Dividend_Tracker: No transfers allowed&quot;);\n    &#125;\n \n    function withdrawDividend() public override &#123;\n        require(false, &quot;RedCheCoin_Dividend_Tracker: withdrawDividend disabled. Use the &#39;claim&#39; function on the main RedCheCoin contract.&quot;);\n    &#125;\n    &#x2F;&#x2F;此函数用于account形参地址不在分红内\n    function excludeFromDividends(address account) external onlyOwner &#123;\n        &#x2F;&#x2F;false就执行，否则退出此函数，主要检测有没有执行过此函数\n        require(!excludedFromDividends[account]);\n        excludedFromDividends[account] &#x3D; true;      &#x2F;&#x2F;设置分红账号为true\n        _setBalance(account, 0);                    &#x2F;&#x2F;设置目前的余额\n        tokenHoldersMap.remove(account);             \n \n        emit ExcludeFromDividends(account);\n    &#125;\n \n    function updateClaimWait(uint256 newClaimWait) external onlyOwner &#123;\n        require(newClaimWait !&#x3D; claimWait, &quot;RedCheCoin_Dividend_Tracker: Cannot update claimWait to same value&quot;);\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\n        claimWait &#x3D; newClaimWait;\n    &#125;\n \n    function getLastProcessedIndex() external view returns (uint256) &#123;\n        return lastProcessedIndex;\n    &#125;\n \n    function getNumberOfTokenHolders() external view returns (uint256) &#123;\n        return tokenHoldersMap.keys.length;\n    &#125;\n \n \n    function getAccount(address _account)\n    public view returns (\n        address account,\n        int256 index,\n        int256 iterationsUntilProcessed,\n        uint256 withdrawableDividends,\n        uint256 totalDividends,\n        uint256 lastClaimTime,\n        uint256 nextClaimTime,\n        uint256 secondsUntilAutoClaimAvailable) &#123;\n        account &#x3D; _account;\n \n        index &#x3D; tokenHoldersMap.getIndexOfKey(account);\n \n        iterationsUntilProcessed &#x3D; - 1;\n \n        if (index &gt;&#x3D; 0) &#123;\n            if (uint256(index) &gt; lastProcessedIndex) &#123;\n                iterationsUntilProcessed &#x3D; index.sub(int256(lastProcessedIndex));\n            &#125;\n            else &#123;\n                uint256 processesUntilEndOfArray &#x3D; tokenHoldersMap.keys.length &gt; lastProcessedIndex ?\n                tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\n                0;\n \n \n                iterationsUntilProcessed &#x3D; index.add(int256(processesUntilEndOfArray));\n            &#125;\n        &#125;\n \n \n        withdrawableDividends &#x3D; withdrawableDividendOf(account);\n        totalDividends &#x3D; accumulativeDividendOf(account);\n \n        lastClaimTime &#x3D; lastClaimTimes[account];\n \n        nextClaimTime &#x3D; lastClaimTime &gt; 0 ?\n        lastClaimTime.add(claimWait) :\n        0;\n \n        secondsUntilAutoClaimAvailable &#x3D; nextClaimTime &gt; block.timestamp ?\n        nextClaimTime.sub(block.timestamp) :\n        0;\n    &#125;\n \n    function getAccountAtIndex(uint256 index)\n    public view returns (\n        address,\n        int256,\n        int256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256) &#123;\n        if (index &gt;&#x3D; tokenHoldersMap.size()) &#123;\n            return (0x0000000000000000000000000000000000000000, - 1, - 1, 0, 0, 0, 0, 0);\n        &#125;\n \n        address account &#x3D; tokenHoldersMap.getKeyAtIndex(index);\n \n        return getAccount(account);\n    &#125;\n \n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) &#123;\n        if (lastClaimTime &gt; block.timestamp) &#123;\n            return false;\n        &#125;\n \n        return block.timestamp.sub(lastClaimTime) &gt;&#x3D; claimWait;\n    &#125;\n \n    function setBalance(address payable account, uint256 newBalance) external onlyOwner &#123;\n        if (excludedFromDividends[account]) &#123;\n            return;\n        &#125;\n \n        if (newBalance &gt;&#x3D; minimumTokenBalanceForDividends) &#123;\n            _setBalance(account, newBalance);\n            tokenHoldersMap.set(account, newBalance);\n        &#125;\n        else &#123;\n            _setBalance(account, 0);\n            tokenHoldersMap.remove(account);\n        &#125;\n \n        processAccount(account, true);\n    &#125;\n \n    function process(uint256 gas) public returns (uint256, uint256, uint256) &#123;\n        uint256 numberOfTokenHolders &#x3D; tokenHoldersMap.keys.length;\n \n        if (numberOfTokenHolders &#x3D;&#x3D; 0) &#123;\n            return (0, 0, lastProcessedIndex);\n        &#125;\n \n        uint256 _lastProcessedIndex &#x3D; lastProcessedIndex;\n \n        uint256 gasUsed &#x3D; 0;\n \n        uint256 gasLeft &#x3D; gasleft();\n \n        uint256 iterations &#x3D; 0;\n        uint256 claims &#x3D; 0;\n \n        while (gasUsed &lt; gas &amp;&amp; iterations &lt; numberOfTokenHolders) &#123;\n            _lastProcessedIndex++;\n \n            if (_lastProcessedIndex &gt;&#x3D; tokenHoldersMap.keys.length) &#123;\n                _lastProcessedIndex &#x3D; 0;\n            &#125;\n \n            address account &#x3D; tokenHoldersMap.keys[_lastProcessedIndex];\n \n            if (canAutoClaim(lastClaimTimes[account])) &#123;\n                if (processAccount(payable(account), true)) &#123;\n                    claims++;\n                &#125;\n            &#125;\n \n            iterations++;\n \n            uint256 newGasLeft &#x3D; gasleft();\n \n            if (gasLeft &gt; newGasLeft) &#123;\n                gasUsed &#x3D; gasUsed.add(gasLeft.sub(newGasLeft));\n            &#125;\n \n            gasLeft &#x3D; newGasLeft;\n        &#125;\n \n        lastProcessedIndex &#x3D; _lastProcessedIndex;\n \n        return (iterations, claims, lastProcessedIndex);\n    &#125;\n \n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) &#123;\n        uint256 amount &#x3D; _withdrawDividendOfUser(account);\n \n        if (amount &gt; 0) &#123;\n            lastClaimTimes[account] &#x3D; block.timestamp;\n            emit Claim(account, amount, automatic);\n            return true;\n        &#125;\n \n        return false;\n    &#125;\n&#125;","slug":"详解分红其他代币，添加流动性合约/index","date":"2022-03-18T15:55:32.000Z","categories_index":"Solidity","tags_index":"区块链,Solidity,智能合约","author_index":"Bug Designer"},{"id":"bbdea3a6ec34b778554399878ace6b88","title":"代币的防机器人机制","content":"solidity防机器人有两种方式一种是根据判断在几区块，另外一种是根据时间来检测\n先用第一种判断时间来检测机器人，照例用以前的代码再新加判断机器人的逻辑\n&#x2F;&#x2F; SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\nimport &quot;.&#x2F;ERC20.sol&quot;;\ncontract Token is ERC20&#123;\n \n   string private _name;    &#x2F;&#x2F;币名字\n    string private _symbol;      &#x2F;&#x2F;币符号\n    address public deadwallet &#x3D; 0x0000000000000000000000000000000000000000;    &#x2F;&#x2F;销毁地址\n    address public LiquityWallet;            &#x2F;&#x2F;铸币钱包\n    mapping(address &#x3D;&gt; bool) public _isBlacklisted;    &#x2F;&#x2F;是否是黑名单,true表示这个地址是黑名单\n     uint256 public tradingEnabledTimestamp &#x3D; 1627779600; &#x2F;&#x2F;10:00pm       &#x2F;&#x2F;2021-08-1 9:00:00的时间戳，这里设置开盘时间，开盘时间逻辑后面再提，这里先注重防机器人\n    &#x2F;*\n     * @dev 返回代币的名字\n     *&#x2F;\n    function name() public view virtual returns (string memory) &#123;\n        return _name;\n    &#125;\n    &#x2F;**\n     * @dev 返回代币的符号\n     *&#x2F;\n    function symbol() public view virtual returns (string memory) &#123;\n        return _symbol;\n    &#125;\n    &#x2F;**\n     * 返回代币精度\n     *&#x2F;\n    function decimals() public pure virtual returns (uint8) &#123;\n        return 18;\n    &#125;\n    constructor() public&#123;\n        _name&#x3D;&#39;Token&#39;;\n        _symbol&#x3D;&#39;Tk&#39;;\n        _mint(msg.sender, 10000000000000 * (10 ** 18));            &#x2F;&#x2F;铸币给连接此合约的账号于10000000000000个币;\n        LiquityWallet&#x3D;msg.sender;\n    &#125;\n     &#x2F;&#x2F;交易函数\n     function _transfer(address recipient, uint256 amount) public returns (bool) &#123;\n        require(!_isBlacklisted[msg.sender], &#39;Blacklisted address&#39;);      &#x2F;&#x2F;如果发送方是黑名单则禁止交易\n        if(LiquityWallet!&#x3D;msg.sender) return super.transfer(recipient, amount); &#x2F;&#x2F;如果铸币方是发送方则不需要销毁\n         if(block.timestamp &lt;&#x3D; tradingEnabledTimestamp + 9 seconds) &#123;  &#x2F;&#x2F;当前块的时间戳小于等于 可交易时间戳+9秒。\n            addBot(msg.sender);                                   &#x2F;&#x2F;把当前地址添加黑名单\n         &#125;                                 \n        uint256 BurnWallet &#x3D; amount.mul(5).div(100);       &#x2F;&#x2F;销毁百分之5\n        uint256 trueAmount &#x3D; amount.sub(BurnWallet);   &#x2F;&#x2F;剩下的95%就是要发送的\n        super.transfer(deadwallet, BurnWallet);          &#x2F;&#x2F;销毁这百分之5\n        return super.transfer(recipient, trueAmount);     &#x2F;&#x2F;发送那95%的代币\n    &#125;\n    \n    function _transferFrom(address sender, address recipient, uint256 amount) public returns (bool) &#123;\n        require(!_isBlacklisted[msg.sender], &#39;Blacklisted address&#39;);      &#x2F;&#x2F;如果发送方是黑名单则禁止交易\n        if(LiquityWallet!&#x3D;msg.sender) return super.transfer(recipient, amount); &#x2F;&#x2F;如果铸币方是发送方则不需要销毁\n         if(block.timestamp &lt;&#x3D; tradingEnabledTimestamp + 9 seconds) &#123;  &#x2F;&#x2F;当前块的时间戳小于等于 可交易时间戳+9秒。\n            addBot(msg.sender);                                   &#x2F;&#x2F;把当前地址添加黑名单\n         &#125; \n        uint256 BurnWallet &#x3D; amount.mul(5).div(100);       &#x2F;&#x2F;销毁百分之5\n        uint256 trueAmount &#x3D; amount.sub(BurnWallet);       &#x2F;&#x2F;剩下的95就是要发送的\n        super.transferFrom(sender, deadwallet, BurnWallet);   &#x2F;&#x2F;销毁这百分之5\n        return super.transferFrom(sender, recipient, trueAmount);  &#x2F;&#x2F;发送那95%的代币\n    &#125;\n        &#x2F;&#x2F;设置黑名单地址\n    function blacklistAddress(address account, bool value) public &#123;\n        _isBlacklisted[account] &#x3D; value;   &#x2F;&#x2F;如果是true就是黑名单\n    &#125;\n    &#x2F;&#x2F;添加黑名单的函数\n    function addBot(address recipient) private &#123;\n        if (!_isBlacklisted[recipient]) _isBlacklisted[recipient] &#x3D; true;\n    &#125;\n&#125;\n在上面的代码中防机器人逻辑主要是如果机器人在开盘9秒内买的就拉进黑名单，不给交易。\n第二种方式代码：\n&#x2F;&#x2F; SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\nimport &quot;.&#x2F;ERC20.sol&quot;;\ncontract Token is ERC20&#123;\n \n   string private _name;    &#x2F;&#x2F;币名字\n    string private _symbol;      &#x2F;&#x2F;币符号\n    address public deadwallet &#x3D; 0x0000000000000000000000000000000000000000;    &#x2F;&#x2F;销毁地址\n    address public LiquityWallet;            &#x2F;&#x2F;铸币钱包\n    mapping(address &#x3D;&gt; bool) public _isBlacklisted;    &#x2F;&#x2F;是否是黑名单,true表示这个地址是黑名单\n     uint256 public tradingEnabledTimestamp &#x3D; 1627779600;       &#x2F;&#x2F;2021-08-1 9:00:00的时间戳，这里设置开盘时间，开盘时间逻辑后面再提，这里先注重防机器人\n     uint256 public launchedAt&#x3D;0;                                   \n    &#x2F;*\n     * @dev 返回代币的名字\n     *&#x2F;\n    function name() public view virtual returns (string memory) &#123;\n        return _name;\n    &#125;\n    &#x2F;**\n     * @dev 返回代币的符号\n     *&#x2F;\n    function symbol() public view virtual returns (string memory) &#123;\n        return _symbol;\n    &#125;\n    &#x2F;**\n     * 返回代币精度\n     *&#x2F;\n    function decimals() public pure virtual returns (uint8) &#123;\n        return 18;\n    &#125;\n    constructor() public&#123;\n        _name&#x3D;&#39;Token&#39;;\n        _symbol&#x3D;&#39;Tk&#39;;\n        _mint(msg.sender, 10000000000000 * (10 ** 18));            &#x2F;&#x2F;铸币给连接此合约的账号于10000000000000个币;\n        LiquityWallet&#x3D;msg.sender;\n    &#125;\n     &#x2F;&#x2F;交易函数\n     function _transfer(address recipient, uint256 amount) public returns (bool) &#123;\n        require(!_isBlacklisted[msg.sender], &#39;Blacklisted address&#39;);      &#x2F;&#x2F;如果发送方是黑名单则禁止交易\n        if(LiquityWallet!&#x3D;msg.sender) return super.transfer(recipient, amount); &#x2F;&#x2F;如果铸币方是发送方则不需要销毁\n        if (launchedAt &#x3D;&#x3D; 0) &#123;   \n            launchedAt &#x3D; block.number;                       &#x2F;&#x2F;初始化lauchAt赋值当前块的数量\n        &#125;\n        if (block.number &lt; launchedAt + 3) &#123;                     &#x2F;&#x2F;如果在3个区间内抢到\n                 addBot(msg.sender);                                    &#x2F;&#x2F;则添加黑名单\n        &#125;                                 \n        uint256 BurnWallet &#x3D; amount.mul(5).div(100);       &#x2F;&#x2F;销毁百分之5\n        uint256 trueAmount &#x3D; amount.sub(BurnWallet);   &#x2F;&#x2F;剩下的95%就是要发送的\n        super.transfer(deadwallet, BurnWallet);          &#x2F;&#x2F;销毁这百分之5\n        return super.transfer(recipient, trueAmount);     &#x2F;&#x2F;发送那95%的代币\n    &#125;\n    \n    function _transferFrom(address sender, address recipient, uint256 amount) public returns (bool) &#123;\n        require(!_isBlacklisted[msg.sender], &#39;Blacklisted address&#39;);      &#x2F;&#x2F;如果发送方是黑名单则禁止交易\n        if(LiquityWallet!&#x3D;msg.sender) return super.transfer(recipient, amount); &#x2F;&#x2F;如果铸币方是发送方则不需要销毁\n         if (launchedAt &#x3D;&#x3D; 0) &#123;   \n            launchedAt &#x3D; block.number;                       &#x2F;&#x2F;初始化lauchAt赋值当前块的数量\n        &#125;\n        if (block.number &lt; launchedAt + 3) &#123;                     &#x2F;&#x2F;如果在3个区间内抢到\n                 addBot(msg.sender);                                    &#x2F;&#x2F;则添加黑名单\n        &#125;\n        uint256 BurnWallet &#x3D; amount.mul(5).div(100);       &#x2F;&#x2F;销毁百分之5\n        uint256 trueAmount &#x3D; amount.sub(BurnWallet);       &#x2F;&#x2F;剩下的95就是要发送的\n        super.transferFrom(sender, deadwallet, BurnWallet);   &#x2F;&#x2F;销毁这百分之5\n        return super.transferFrom(sender, recipient, trueAmount);  &#x2F;&#x2F;发送那95%的代币\n    &#125;\n        &#x2F;&#x2F;设置黑名单地址\n    function blacklistAddress(address account, bool value) public &#123;\n        _isBlacklisted[account] &#x3D; value;   &#x2F;&#x2F;如果是true就是黑名单\n    &#125;\n    &#x2F;&#x2F;添加黑名单的函数\n    function addBot(address recipient) private &#123;\n        if (!_isBlacklisted[recipient]) _isBlacklisted[recipient] &#x3D; true;\n    &#125;\n&#125;","slug":"代币的防机器人机制/index","date":"2022-03-18T15:50:26.000Z","categories_index":"Solidity","tags_index":"区块链,Solidity","author_index":"Bug Designer"},{"id":"39ca82df4b5e6da28b6e5b90eb3517e9","title":"教你发行BSC链上可分其他代币|含营销钱包|通缩|回流 智能合约","content":"支持分红SHIB ETH USDT DOGE等BSC所有代币。\nRemixhttps://remix.ethereum.org/\n编译/开源参数COMPILER: v0.8.4+commit.e28d00a7.js\nEnable optimization: 开启并使用默认值200\nOther Settings: default evmVersion, MIT license\n合约核心源码\nconstructor(\n    string memory name_,\n    string memory symbol_,\n    uint256 totalSupply_,\n    address[2] memory addrs, &#x2F;&#x2F; reward, marketing wallet\n    uint256[3] memory feeSettings, &#x2F;&#x2F; rewards, liquidity, marketing\n    uint256 minimumTokenBalanceForDividends_\n) payable ERC20(name_, symbol_) &#123;\n    rewardToken &#x3D; addrs[0];\n    _marketingWalletAddress &#x3D; addrs[1];\n    require(\n        msg.sender !&#x3D; _marketingWalletAddress,\n        &quot;Owner and marketing wallet cannot be the same&quot;\n    );\n    totalSupply_ &#x3D; totalSupply_ * 10**18;\n    tokenRewardsFee &#x3D; feeSettings[0];\n    liquidityFee &#x3D; feeSettings[1];\n    marketingFee &#x3D; feeSettings[2];\n    totalFees &#x3D; tokenRewardsFee.add(liquidityFee).add(marketingFee);\n    require(totalFees &lt;&#x3D; 25, &quot;Total fee is over 25%&quot;);\n    swapTokensAtAmount &#x3D; totalSupply_.mul(2).div(10**6); &#x2F;&#x2F; 0.002%\n\n    &#x2F;&#x2F; use by default 300,000 gas to process auto-claiming dividends\n    gasForProcessing &#x3D; 300000;\n\n    dividendTracker &#x3D; BABYTOKENDividendTracker(\n        payable(Clones.clone(0xD2EE2Be66DD5Dd596469CDbac00b5Ad2554F80ea))\n    );\n    dividendTracker.initialize(\n        rewardToken,\n        minimumTokenBalanceForDividends_\n    );\n\n    IUniswapV2Router02 _uniswapV2Router &#x3D; IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    &#x2F;&#x2F; Create a uniswap pair for this new token\n    address _uniswapV2Pair &#x3D; IUniswapV2Factory(_uniswapV2Router.factory())\n        .createPair(address(this), _uniswapV2Router.WETH());\n    uniswapV2Router &#x3D; _uniswapV2Router;\n    uniswapV2Pair &#x3D; _uniswapV2Pair;\n    _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\n\n    &#x2F;&#x2F; exclude from receiving dividends\n    dividendTracker.excludeFromDividends(address(dividendTracker));\n    dividendTracker.excludeFromDividends(address(this));\n    dividendTracker.excludeFromDividends(owner());\n    dividendTracker.excludeFromDividends(address(0xdead));\n    dividendTracker.excludeFromDividends(address(_uniswapV2Router));\n    &#x2F;&#x2F; exclude from paying fees or having max transaction amount\n    excludeFromFees(owner(), true);\n    excludeFromFees(_marketingWalletAddress, true);\n    excludeFromFees(address(this), true);\n    &#x2F;*\n        _mint is an internal function in ERC20.sol that is only called here,\n        and CANNOT be called ever again\n    *&#x2F;\n    _mint(owner(), totalSupply_);\n\n    emit TokenCreated(owner(), address(this), TokenType.baby, VERSION);\n\n    payable(serviceFeeReceiver_).transfer(serviceFee_);\n&#125;\n\nreceive() external payable &#123;&#125;\n\nfunction updateDividendTracker(address newAddress) public onlyOwner &#123;\n    require(\n        newAddress !&#x3D; address(dividendTracker),\n        &quot;BABYTOKEN: The dividend tracker already has that address&quot;\n    );\n\n    BABYTOKENDividendTracker newDividendTracker &#x3D; BABYTOKENDividendTracker(\n        payable(newAddress)\n    );\n\n    require(\n        newDividendTracker.owner() &#x3D;&#x3D; address(this),\n        &quot;BABYTOKEN: The new dividend tracker must be owned by the BABYTOKEN token contract&quot;\n    );\n\n    newDividendTracker.excludeFromDividends(address(newDividendTracker));\n    newDividendTracker.excludeFromDividends(address(this));\n    newDividendTracker.excludeFromDividends(owner());\n    newDividendTracker.excludeFromDividends(address(uniswapV2Router));\n\n    emit UpdateDividendTracker(newAddress, address(dividendTracker));\n\n    dividendTracker &#x3D; newDividendTracker;\n&#125;\n\n \n\n\n部署参数Value填写：200000000000000000 CONTRACT 选择 Babytoken，name_: BTC COIN (代币名称)symbol_: BTC (代币简称)totalSupply_: 21000000 (发行量 发多少就写多少)addds_: [“0x2859e4544C4bB03966803b044A93563Bd2D0DD4D”,”0x2859e4544C4bB03966803b044A93563Bd2D0DD4D”] (要分红的代币合约、营销钱包)feeSettings_: [4,3,1] (分红、流动性、营销钱包)minimumTokenBalanceForDividends_: 10000000000000000000000 (持有多少代币参与分红。数量后要加18个0)\nBSC常用代币合约地址SHIB: 0x2859e4544C4bB03966803b044A93563Bd2D0DD4DUSDT: 0x55d398326f99059fF775485246999027B3197955ETH:  0x2170Ed0880ac9A755fd29B2688956BD959F933F8DOGE: 0xbA2aE424d960c26247Dd6c32edC70B295c744C43BUSD: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56CAKE: 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82\n有任何问题请联系QQ：2510472590\n","slug":"教你发行BSC链上可分其他代币-含营销钱包-通缩-回流-智能合约/index","date":"2022-03-17T18:50:05.000Z","categories_index":"发币教程","tags_index":"区块链,BSC,教程","author_index":"Bug Designer"},{"id":"b0741c11219613863ac494c737cd8897","title":"Linux常见命令","content":"1.常见操作命令cd home, cd home&#x2F;tomcat # 定位到某个目录\ncd ..&#x2F; # 回到上一层目录\nls # 显示当前文件夹下的文件\ntab键 # 自动完成\nmkdir 文件夹名 # 新建文件夹\nmv 旧名称 新名称 # 移动文件，也可以用来重命名\nrm -rf 文件名 # 删除文件或者文件夹，其中，r表示递归删除子文件，f表示强制删除无需确认\n某个命令 --help # linux下大部分命令查看帮助方法\ncp -r 旧文件夹名 新文件夹名 # 复制文件夹或者文件，-r表示递归\nchmod 777 startup.sh # 给某个文件添加执行权限\ncurl http:&#x2F;&#x2F;liuxianan.com # 访问某个网址，返回HTML代码\nwget http:&#x2F;&#x2F;xxx.com&#x2F;123.zip # 下载文件\npkill node，pkill nginx # 强制杀死某个进程\n其它：\npwd # 查看当前目录\nwhoami # 查看当前登录用户\nwhich 某个命令 # 查看某个命令在path中所在路径\nwhere 某个命令 # 磁盘搜索某个命令\n2.查看磁盘空间、文件大小df -h # 查看所有磁盘剩余空间\ndu -h # 查看当前目录所有文件夹大小（包括子文件夹），-h 是转换成友好格式显示\ndu -h 文件夹名称 # 查看某个文件夹大小（包括子文件夹），由于会包括子文件，所以不要在根目录运行此命令，否则要等很久\ndu -sh 文件夹名称 # 查看某个文件夹大小（不包括子文件夹）\n很多人时间一长都分不清df和du，该如何记忆呢？这样记：\ndf &#x3D;&#x3D; Disk Free &#x3D;&#x3D; 磁盘剩余空间\ndu &#x3D;&#x3D; Disk Usage &#x3D;&#x3D; 磁盘已使用空间\n另外注意，在没有分区和格式化数据盘之前，使用 df –h命令，是无法看到数据盘的，可以使用fdisk -l命令查看。\n3.修改hosts直接vi /etc/hosts，修改完后跟windows一样会立即生效。\n4.解压压缩相关命令4.1. tartar -cvf FileName.tar DirName # 打包，其中c表示create，v表示verbosely（显示过程）\ntar -xvf FileName.tar # 解包，其中x表示extract\n注意：以上命令只是打包，不是压缩！\n4.2. gzgzip只能压缩单个文件：\ngzip FileName # 压缩，不会保留源文件\ngzip -d FileName.gz # 解压\n4.3. tar.gz 和 tgztar -zcvf FileName.tar.gz DirName # 压缩，注意是先写输出文件名，再写文件夹名\ntar -zxvf FileName.tar.gz # 解压到当前目录，文件名在原始基础上去掉后缀\n\n\n","slug":"Linux常见命令/index","date":"2022-03-16T17:39:07.000Z","categories_index":"操作系统","tags_index":"Linux","author_index":"Bug Designer"},{"id":"36c610caa1e43df0d3165a993cf0c93d","title":"Java使用Web3j进行eth和token转账","content":"ETH转账public static void transfer() throws Exception &#123;\n    Web3j web3j = Web3j.build(new HttpService(\"infura节点链接\"));\n    BigInteger bigInteger = new BigInteger(\"钱包私钥\", 16);\n    ECKeyPair ecKeyPair = ECKeyPair.create(bigInteger);\n    Credentials credentials = Credentials.create(ecKeyPair);\n    TransactionReceipt transactionReceipt = Transfer.sendFunds(web3j, credentials, \"目标地址\", BigDecimal.valueOf(0.001), Convert.Unit.ETHER).send();\n    System.out.println(transactionReceipt);\n&#125;\nToken转账public static void transferToken() throws Exception &#123;\n    Web3j web3j = Web3j.build(new HttpService(\"infura节点链接\"));\n    BigInteger bigInteger = new BigInteger(\"私钥\", 16);\n    ECKeyPair ecKeyPair = ECKeyPair.create(bigInteger);\n    Credentials credentials = Credentials.create(ecKeyPair);\n    String fromAddress = credentials.getAddress();\n    EthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount(\n            fromAddress, DefaultBlockParameterName.LATEST).sendAsync().get();\n    BigInteger nonce = ethGetTransactionCount.getTransactionCount();\n\n    Address address = new Address(\"目标地址\");\n    Uint256 value = new Uint256(new BigInteger(\"数量 单位wei\"));\n    List&lt;Type> parametersList = new ArrayList&lt;>();\n    parametersList.add(address);\n    parametersList.add(value);\n    List&lt;TypeReference&lt;?>> outList = new ArrayList&lt;>();\n    Function function = new Function(\"transfer\", parametersList, outList);\n    String encodedFunction = FunctionEncoder.encode(function);\n    System.out.println( DefaultGasProvider.GAS_PRICE);\n    System.out.println(DefaultGasProvider.GAS_LIMIT);\n    RawTransaction rawTransaction = RawTransaction.createTransaction(nonce,  DefaultGasProvider.GAS_PRICE,\n            new BigInteger(\"210000\"), \"合约地址\", encodedFunction);\n    byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\n    String hexValue = Numeric.toHexString(signedMessage);\n    EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).sendAsync().get();\n    Object transactionHash = ethSendTransaction.getTransactionHash();\n    System.out.println(transactionHash.toString());\n&#125;\n","slug":"Java使用Web3j进行eth和token转账/index","date":"2022-03-16T17:03:24.000Z","categories_index":"Web3","tags_index":"区块链,Java,Web3j","author_index":"Bug Designer"},{"id":"3185ced86f4b8df05c544660439ae3e8","title":"教你智能合约放弃所有权","content":"准备工作\nERC20标准代币会自己发行\n准备好【权限控制】相关代码\n有足够的币来支付gas费用\n\n对发布智能合约有疑问请参考我的另一篇文章《从零教你发行自己的以太坊ERC20智能合约》\n相关操作请在需要拥有【丢弃权限】功能的合约中添加以下代码，发币完成后执行renounceOwnership()函数即可完成丢弃权限操作，此时权限地址为0x0000000000000000000000000000000000000000\n\n\n\n\n\n\n\n\n\n注：renounceOwnership()操作不可挽回！\ncontract Ownable is Context &#123;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    &#x2F;&#x2F;构造函数\n    constructor () internal &#123;\n        address msgSender &#x3D; _msgSender();\n        _owner &#x3D; msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n\n    &#x2F;&#x2F;权限所有人\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    &#x2F;**\n     * 只有管理员可以操作\n     *&#x2F;\n    modifier onlyOwner() &#123;\n        require(_owner &#x3D;&#x3D; _msgSender(), &quot;Ownable: caller is not the owner&quot;);\n        _;\n    &#125;\n\n     &#x2F;**\n     * 丢弃权限\n     *&#x2F;\n    function renounceOwnership() public virtual onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner &#x3D; address(0);\n    &#125;\n\n    &#x2F;**\n     * @dev 将合同的所有权转移到一个新帐户（“newOwner”）。\n\t *      只能由当前所有者调用。\n     *&#x2F;\n    function transferOwnership(address newOwner) public virtual onlyOwner &#123;\n        require(newOwner !&#x3D; address(0), &quot;Ownable: new owner is the zero address&quot;);\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner &#x3D; newOwner;\n    &#125;\n&#125;","slug":"教你智能合约放弃所有权/index","date":"2022-03-16T16:53:39.000Z","categories_index":"发币教程","tags_index":"区块链,教程","author_index":"Bug Designer"},{"id":"a182aad2ec9a53a04c3cddb2b5345335","title":"手把手教你在opensea出售自己的NFT","content":"一、链接钱包本文所使用Rinkeby网络，打开官网链接钱包\n二、发行ERC721智能合约1、使用remix部署过程参考erc20智能合约，详见这篇文章\n2、在浏览器上进行合约开源开源的目的是为了更好的使用铸造方法链接钱包后我们使用铸造方法进行部署智能合约此处注意在uri栏中需要填入智能合约元数据，包含但不限于名称、logo、描述等信息，相见官网文档\n3、铸造完成后即可在【我的收集】中看到这个项目了点击进入后即可看到我们设置的相关信息\n结尾至此在opensea上发行我们自己的erc721智能合约教学即完成了\n","slug":"手把手教你在opensea出售自己的NFT/index","date":"2022-03-16T16:51:15.000Z","categories_index":"发币教程","tags_index":"区块链,教程","author_index":"Bug Designer"},{"id":"578d782843ce03dcc508f17328e6af31","title":"手把手教你在BSC主链上发币|BSC发币","content":"一、什么是币安智能链？\n\n\n\n\n\n\n\n\n币安智能链（BSC）可以被描述为与币安链并行的区块链。与币安链不同的地方在于，BSC拥有智能合约功能并与以太坊虚拟机（EVM）兼容。这里的设计目标是保持完整币安链的高吞吐量，同时将智能合约引入其生态系统。\n本质上两个区块链都是并行的。值得注意的是BSC并非所谓的第二层或链外扩展性解决方案。它是一个即使币安链下线后也可以运行的独立区块链。从设计的角度来看，这两个链非常相似。\n由于BSC与EVM兼容，因此它支持以太坊工具和DApp。理论上讲这使开发人员可以轻松地从以太坊移植其项目。对于用户而言，这表示他们可以轻松配置诸如MetaMask之类的应用程序与BSC一起使用，只需调整几个设置即可。\n二、相关信息官网：https://www.binance.org/cn\n区块链浏览器：https://bscscan.com/\n开发文档：https://docs.binance.org/index.html\n三、发智能合约教程1、安装metamask插件下载地址：https://metamask.io/\n2、添加自定义网络：chainid: 56\nrpc: https://bsc-dataseed.binance.org/\nscan: https://bscscan.com\n3、使用Remix部署合约Remix是在线的合约开发和部署工具。首先打开Remix页面\n\n左侧文件浏览器内，新建文件，比如Example.sol，在右侧编辑合约内容。\n\n编译合约\n点击左侧按钮，切换到编译界面；\n选择对应的合约；\n设置相关的编译选项；\n点击编译按钮进行编译；\n\n接下来要将编译后的合约部署到链上\n\n最后一步点击“确认”按钮以签署交易并向BSC广播交易\n","slug":"手把手教你在BSC主链上发币-BSC发币/index","date":"2022-03-16T10:38:19.000Z","categories_index":"发币教程","tags_index":"区块链,BSC,教程","author_index":"Bug Designer"}]