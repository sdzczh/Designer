{"title":"一些简单的 Gas 优化基础","uid":"743b68934be546ac8b4b7cd46c619570","slug":"一些简单的-Gas-优化基础/index","date":"2022-03-24T13:28:30.000Z","updated":"2022-03-24T16:26:30.874Z","comments":true,"path":"api/articles/一些简单的-Gas-优化基础/index.json","keywords":null,"cover":null,"content":"<p>编写智能合约是很难的。不仅是要确保代码没有漏洞，而且你的编写方式还会影响到用户与它交互时的开销。</p>\n<p>当你在编译智能合约时，每一行 Solidity 代码都会转换为一系列的操作(操作码)，这些操作都有对应的 gas 消耗。你的目标就是要让你的程序使用尽可能少的操作码(或者用更便宜的)。</p>\n<p>当然，这些都很复杂，所以，我们要慢慢来。与其陷入操作码兔子洞，不如尝试一些可以直接应用到合约里的简单优化。</p>\n<h1 id=\"升级-Solidity-版本\"><a href=\"#升级-Solidity-版本\" class=\"headerlink\" title=\"升级 Solidity 版本\"></a>升级 Solidity 版本</h1><p>合约中，Solidity 版本是在文件最顶部定义的，像这样：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pragma solidity ^0.8.0;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在这里，<code>^0.8.0</code>意思是合约使用<code>0.8.x</code>系列最新可用的Solidity版本。</p>\n<p>更新的 Solidity 版本有时会在修复bug和安全补丁时就优化了 gas ，所以，升级到最新版本不仅会让你的代码更安全，通常也会更便宜。</p>\n<p>要捕获最近大多数优化，请确保你的版本在<code>0.8.4</code>以上：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pragma solidity ^0.8.4;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h1 id=\"放弃-Counters-sol\"><a href=\"#放弃-Counters-sol\" class=\"headerlink\" title=\"放弃 Counters.sol\"></a>放弃 Counters.sol</h1><p>如果你的 NFT 项目或者代币正在使用 OpenZeppelin 合约，很可能你正在用 OZ 的<code>Counters.sol</code>库。</p>\n<p>在较新的 Solidity 版本(<code>0.8</code>的更高版本)，这个库并不是很有用，用常规整数替代它可以节省一些gas：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">contract TestCounters &#123;\n-\tusing Counters for Counters.Counter;\n-\tCounters.Counter private _tokenIds;\n\t\n+\tuint256 private _tokenId;\n\t\n\tfunction mint() public &#123;\n-\t\t_tokenIds.increment();\n-\t\tuint256 tokenId &#x3D; _tokenIds.current();\n\t\t\n+\t\tuint256 tokenId &#x3D; _tokenId++;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"标记不可变变量\"><a href=\"#标记不可变变量\" class=\"headerlink\" title=\"标记不可变变量\"></a>标记不可变变量</h1><p>无论是代币的小数位数，USDC 的地址，还是支付账户，有时我们并不打算更改合约变量。此时，将它们标记为常量（如果你在代码中编写它们）或者不可变量（如果你计划之后给它们赋值，比如，通过构造函数）可以降低访问这些值时的开销：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">contract TestImmutable &#123;\n\tuint256 internal constant DECIMALS &#x3D; 18;\n\taddress public immutable currencyToken;\n\t\n\tconstructor(address _currencyToken) &#123;\n\t\tcurrencyToken &#x3D; _currencyToken;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"unchecked\"><a href=\"#unchecked\" class=\"headerlink\" title=\"unchecked {}\"></a>unchecked {}</h1><p>从 Solidity <code>0.8</code>开始，所有数学运算都包括溢出检查。这是很棒的（替换了 SafeMath 库，如果你还在用可以丢弃了），但是它需要额外的 gas 开销，所以我们想在不必要的时候绕开它。</p>\n<p>溢出检查的意义在于帮你检查是否存在从 0 减去或者加到 2<br>256<br> （Solidity 可以处理的最大数）以上。所以，如果你只是增加代币id或者存储ERC20值，你应该用<code>unchecked &#123;&#125;</code>退出溢出检查：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">contract TestUnchecked is ERC721 &#123;\n\tERC20 internal immutable paymentToken &#x3D; ERC20(address(0x1));\n\tuint256 internal _tokenId;\n\t\n\tmapping(address &#x3D;&gt; uint256) _balances;\n\t\n\tfunction mint(uint256 amount) public &#123;\n\t\t_mint(msg.sender, _tokenId);\n\t\t\n\t\tunchecked &#123;\n\t\t\t_balances[msg.sender] +&#x3D; amount;\n\t\t\t++tokenId;\n\t\t&#125;\n\t\t\n\t\tpaymentToken.transferFrom(msg.sender, address(this), amount);\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这在for循环中特别方便，i的值永远不会溢出，所以在每次迭代中节省了gas：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">contract TestUncheckedFor &#123;\n\tERC20 internal immutable token &#x3D; ERC20(address(0x1));\n\n\tfunction refundAddresses(address[] calldata accounts) &#123;\n\t\t&#x2F;&#x2F; 💡 pro tip: save the array length to a variable instead of\n\t\t&#x2F;&#x2F; inlining to save gas on every iteration.\n\t\tuint256 len &#x3D; accounts.length;\n\t\t\n\t\tfor (uint256 i &#x3D; 0; i &lt; len; ) &#123;\n\t\t\ttoken.transfer(accounts[i], 1 ether);\n\t\t\t\n\t\t\tunchecked &#123; ++i; &#125;\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"避免将参数复制到内存\"><a href=\"#避免将参数复制到内存\" class=\"headerlink\" title=\"避免将参数复制到内存\"></a>避免将参数复制到内存</h1><p>对于某些类型的参数，如字符串或者数组，Solidity 会强制指定存储位置(<code>memory</code>或者<code>calldata</code>)。这里用<code>calldata</code>会便宜的多，所以你会希望尽可能多的使用它，而<code>memory</code>只在你需要修改参数时才用（因为<code>calldata</code>会让它们只读）。</p>\n<h1 id=\"使用自定义错误\"><a href=\"#使用自定义错误\" class=\"headerlink\" title=\"使用自定义错误\"></a>使用自定义错误</h1><p>Solidity <code>0.8.4</code>有一个新功能，允许开发者自定义错误，就像定义事件一样：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">contract TestErrors &#123;\n\t&#x2F;&#x2F; first, define the error\n\terror Unauthorized();\n\t\n\t&#x2F;&#x2F; errors can have parameters, like events\n\terror AlreadyMinted(uint256 id);\n\t\n\t&#x2F;&#x2F; 💡 pro tip: this gets set to the deployer address\n\t&#x2F;&#x2F; sometimes, you don&#39;t need Ownable :)\n\taddress internal immutable owner &#x3D; msg.sender;\n\t\n\tmapping(uint256 &#x3D;&gt; address) _ownerOf;\n\t\n\tfunction ownerMint(uint256 tokenId) public &#123;\n\t\tif (msg.sender !&#x3D; owner) revert Unauthorized();\n\t\tif (_ownerOf[tokenId] !&#x3D; address(0)) revert AlreadyMinted(tokenId);\n\t\t\n\t\t_ownerOf[tokenId] &#x3D; msg.sender;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>你应该尝试用自定义错误代替以前的返回字符串(<code>require(true, &quot;error message here&quot;)</code>)，因为不同的错误信息可能会额外增加gas开销。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>当使用任何一种计数器（如<code>_tokenId</code>），从1开始而不是从0开始，会让第一次 mint 便宜一些。通常，写入没有值的槽比写入有值的槽更贵。</p>\n<p>此外，<strong>整数递增</strong>，<code>++i</code>(返回上一次的值，然后再加1)比<code>i++</code>(加1，然后返回新的值)更便宜。如果你仅仅需要一个计数器而不需要它的返回值，你可能会更想要第一种。</p>\n<p><strong>除法</strong>，Solidity 插入了一个检查，确保没有被0除。如果你可以确定除数不为0，你可以使用汇编来执行操作，这样可以节省一些额外的gas：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">contract TestDivision &#123;\n\tfunction divide_by_2(uint256 a) public pure returns (uint256 result) &#123;\n\t\tassembly &#123;\n\t\t\tresult :&#x3D; div(a, 2)\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>最后，标记为<code>payable</code>的函数会比其他函数调用时便宜。将所有函数标记为 <code>payable</code> 可能会影响用户体验，因为在使用 Etherscan 时会有一个额外字段，可能会意外向合约发送 ETH 。相对安全的优化是将构造函数标记为<code>payable</code>，可以稍微降低一点部署的开销。</p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>虽然很难，但 Solidity 和 EVM 的世界真的很有意思。有些开发者可能花费数天时间来调整代码，只为压缩一点额外的gas消耗。</p>\n<p>我希望上面的清单可以成为一个好的参考，帮助你的合约便宜一点。</p>\n","text":"编写智能合约是很难的。不仅是要确保代码没有漏洞，而且你的编写方式还会影响到用户与它交互时的开销。 当你在编译智能合约时，每一行 Solidity 代码都会转换为一系列的操作(操作码)，这些操作都有对应的 gas 消耗。你的目标就是要让你的程序使用尽可能少的操作码(或者用更便宜的)...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"Solidity","slug":"Solidity","count":4,"path":"api/categories/Solidity.json"}],"tags":[{"name":"区块链","slug":"区块链","count":11,"path":"api/tags/区块链.json"},{"name":"百科","slug":"百科","count":2,"path":"api/tags/百科.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%87%E7%BA%A7-Solidity-%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">升级 Solidity 版本</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%94%BE%E5%BC%83-Counters-sol\"><span class=\"toc-text\">放弃 Counters.sol</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">标记不可变变量</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#unchecked\"><span class=\"toc-text\">unchecked {}</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E5%B0%86%E5%8F%82%E6%95%B0%E5%A4%8D%E5%88%B6%E5%88%B0%E5%86%85%E5%AD%98\"><span class=\"toc-text\">避免将参数复制到内存</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">使用自定义错误</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9D%9F\"><span class=\"toc-text\">结束</span></a></li></ol>","author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"将UniswapV2部署到所有区块链--去中心化交易所Uniswap多链部署","uid":"ef6e40d56e038ad562533ff3b6321d26","slug":"将UniswapV2部署到所有区块链-去中心化交易所Uniswap多链部署/index","date":"2022-03-26T14:52:50.000Z","updated":"2022-03-27T02:45:50.360Z","comments":true,"path":"api/articles/将UniswapV2部署到所有区块链-去中心化交易所Uniswap多链部署/index.json","keywords":null,"cover":[],"text":"准备工作工厂合约工厂合约链接 在主合约添加 bytes32 public constant INIT_CODE_PAIR_HASH &#x3D; keccak256(abi.encodePacked(type(UniswapV2Pair).creationCode)); 编译EV...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Dapp","slug":"Dapp","count":1,"path":"api/categories/Dapp.json"}],"tags":[{"name":"区块链","slug":"区块链","count":11,"path":"api/tags/区块链.json"},{"name":"Solidity","slug":"Solidity","count":4,"path":"api/tags/Solidity.json"},{"name":"教程","slug":"教程","count":5,"path":"api/tags/教程.json"}],"author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}}},"next_post":{"title":"浅谈NFT的元数据标准","uid":"c818a12081dd186c3b840bc9579f9407","slug":"浅谈NFT的元数据标准/index","date":"2022-03-19T14:38:20.000Z","updated":"2022-03-24T16:28:07.792Z","comments":true,"path":"api/articles/浅谈NFT的元数据标准/index.json","keywords":null,"cover":[],"text":"前言为OpenSea等平台提供资产元数据可以为数字资产提供丰富的数据并轻松地在应用程序中显示它们。给定智能合约上的数字资产通常仅由唯一标识符（例如，ERC721 中的 token_id表示，因此元数据允许这些资产具有其他属性，例如名称、描述和图像。 实现令牌URI为了让 Open...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"NFT","slug":"NFT","count":1,"path":"api/categories/NFT.json"}],"tags":[{"name":"区块链","slug":"区块链","count":11,"path":"api/tags/区块链.json"},{"name":"百科","slug":"百科","count":2,"path":"api/tags/百科.json"},{"name":"NFT","slug":"NFT","count":1,"path":"api/tags/NFT.json"}],"author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}}}}