{"title":"通缩分红币Safemoon解读","uid":"0611b829126354c2a4ab4275e956e0b0","slug":"通缩分红币Safemoon解读/index","date":"2022-03-18T16:01:39.000Z","updated":"2022-03-24T16:28:14.304Z","comments":true,"path":"api/articles/通缩分红币Safemoon解读/index.json","keywords":null,"cover":null,"content":"<h1 id=\"1、Safemoon原理\"><a href=\"#1、Safemoon原理\" class=\"headerlink\" title=\"1、Safemoon原理\"></a>1、Safemoon原理</h1><p>Safemoon是一种通缩分红币，通缩指的是每次转账都会收取一定手续费，这些手续费会直接销毁，进而导致总量的通缩。分红指的是，用户的余额会随着其他用户转账而增加。</p>\n<p>Safemoon的基本原理用一个比喻来说就是，将一块固定蛋糕<code>（_tTotal）</code>分给总量会变化的盘子中<code>（_rTotal）</code>，每次转账都会打碎一部分盘子，这样剩余盘子分到的蛋糕就变多了。</p>\n<h1 id=\"2、-数据结构\"><a href=\"#2、-数据结构\" class=\"headerlink\" title=\"2、 数据结构\"></a>2、 数据结构</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">mapping (address &#x3D;&gt; uint256) private _rOwned;\nmapping (address &#x3D;&gt; uint256) private _tOwned;\nmapping (address &#x3D;&gt; mapping (address &#x3D;&gt; uint256)) private _allowances;\n \nmapping (address &#x3D;&gt; bool) private _isExcludedFromFee;\n \nmapping (address &#x3D;&gt; bool) private _isExcluded;\naddress[] private _excluded;\n   \nuint256 private constant MAX &#x3D; ~uint256(0);\nuint256 private _tTotal &#x3D; 1000000000 * 10**6 * 10**9;\nuint256 private _rTotal &#x3D; (MAX - (MAX % _tTotal));\nuint256 private _tFeeTotal;\n \nstring private _name &#x3D; &quot;SafeMoon&quot;;\nstring private _symbol &#x3D; &quot;SAFEMOON&quot;;\nuint8 private _decimals &#x3D; 9;\n\nuint256 public _taxFee &#x3D; 5;\nuint256 private _previousTaxFee &#x3D; _taxFee;\n\nuint256 public _liquidityFee &#x3D; 5;\nuint256 private _previousLiquidityFee &#x3D; _liquidityFee;\n \nIUniswapV2Router02 public immutable uniswapV2Router;\naddress public immutable uniswapV2Pair;\n\nbool inSwapAndLiquify;\nbool public swapAndLiquifyEnabled &#x3D; true;\n\nuint256 public _maxTxAmount &#x3D; 5000000 * 10**6 * 10**9;\nuint256 private numTokensSellToAddToLiquidity &#x3D; 500000 * 10**6 * 10**9;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>_tTotal：对外展示的币总量，为1000000000 * 10<strong>6 * 10</strong>9，可以看出是总的蛋糕</p>\n<p>_rTotal：是内部实际的币总量，为2^256-(2^256%_tTotal)，是一个很大的数，可以看出是盘子的数量</p>\n<p>_rOwned : 用户内部持有的实际币数量，可以看成是每个用户拥有的盘子数量</p>\n<p>_tOwned ：只用于非分红用户的转账，可以看成是一个帮助类</p>\n<p>_allowances：类似于ERC20的allowance，指用户授权某些账户的可使用额度</p>\n<p>_isExcludedFromFee：账户白名单，用来判断是否需要转账手续费</p>\n<p>_isExcluded：账户黑名单，用来判断是否参与分红，默认所有用户都会参与分红</p>\n<p>_excluded：黑名单数组</p>\n<p>_tFeeTotal：收取的手续费，可以看成是打碎了多少盘子，但是不影响总蛋糕_tTotal</p>\n<p>_name：代币名称</p>\n<p>_symbol：代币代码</p>\n<p>_decimals：代币精度</p>\n<p>_taxFee：转账收取的手续费，这部分手续费会直接销毁，进而导致_rTotal减少，也就是总量的通缩。</p>\n<p>_previousTaxFee：上一次设置的手续费，是个历史记录</p>\n<p>_liquidityFee：转账收取的流动性手续费，这部分手续费会添加到uniswap的交易对里</p>\n<p>_previousLiquidityFee：上一次设置的手续费，是个历史记录</p>\n<p>uniswapV2Router：uniswap的路由器，用于添加流动性</p>\n<p>uniswapV2Pair：在uniswap的创建的SafeMoon-ETH交易对</p>\n<p>inSwapAndLiquify：用于lockTheSwap这个modifier，用来加锁的</p>\n<p>swapAndLiquifyEnabled：开关，要不要将流动性手续费添加到uniswap的交易对里</p>\n<p>_maxTxAmount：每次转账最多可转多少代币</p>\n<p>numTokensSellToAddToLiquidity：当累积的流动性手续费大于这个值得时候，才会去uniswap添加流动性</p>\n<h1 id=\"3、构造函数\"><a href=\"#3、构造函数\" class=\"headerlink\" title=\"3、构造函数\"></a>3、构造函数</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">constructor () public &#123;\n        _rOwned[_msgSender()] &#x3D; _rTotal;\n        \n        IUniswapV2Router02 _uniswapV2Router &#x3D; IUniswapV2Router02(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n         &#x2F;&#x2F; Create a uniswap pair for this new token\n        uniswapV2Pair &#x3D; IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n \n        &#x2F;&#x2F; set the rest of the contract variables\n        uniswapV2Router &#x3D; _uniswapV2Router;\n        \n        &#x2F;&#x2F;exclude owner and this contract from fee\n        _isExcludedFromFee[owner()] &#x3D; true;\n        _isExcludedFromFee[address(this)] &#x3D; true;\n        \n        emit Transfer(address(0), _msgSender(), _tTotal);\n    &#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>首先把所有代币设置给合约的部署者，然后通过UniswapV2Router02创建一个交易对，最后将本合约地址和部署者设置成白名单，他们转账不需要收手续费。</p>\n<h1 id=\"4、核心方法\"><a href=\"#4、核心方法\" class=\"headerlink\" title=\"4、核心方法\"></a>4、核心方法</h1><h3 id=\"4-1-transfer\"><a href=\"#4-1-transfer\" class=\"headerlink\" title=\"4.1 _transfer\"></a>4.1 _transfer</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private &#123;\n        require(from !&#x3D; address(0), &quot;ERC20: transfer from the zero address&quot;);\n        require(to !&#x3D; address(0), &quot;ERC20: transfer to the zero address&quot;);\n        require(amount &gt; 0, &quot;Transfer amount must be greater than zero&quot;);\n        if(from !&#x3D; owner() &amp;&amp; to !&#x3D; owner())\n            require(amount &lt;&#x3D; _maxTxAmount, &quot;Transfer amount exceeds the maxTxAmount.&quot;);\n \n        &#x2F;&#x2F; is the token balance of this contract address over the min number of\n        &#x2F;&#x2F; tokens that we need to initiate a swap + liquidity lock?\n        &#x2F;&#x2F; also, don&#39;t get caught in a circular liquidity event.\n        &#x2F;&#x2F; also, don&#39;t swap &amp; liquify if sender is uniswap pair.\n        uint256 contractTokenBalance &#x3D; balanceOf(address(this));\n        \n        if(contractTokenBalance &gt;&#x3D; _maxTxAmount)\n        &#123;\n            contractTokenBalance &#x3D; _maxTxAmount;\n        &#125;\n        \n        bool overMinTokenBalance &#x3D; contractTokenBalance &gt;&#x3D; numTokensSellToAddToLiquidity;\n        if (\n            overMinTokenBalance &amp;&amp;\n            !inSwapAndLiquify &amp;&amp;\n            from !&#x3D; uniswapV2Pair &amp;&amp;\n            swapAndLiquifyEnabled\n        ) &#123;\n            contractTokenBalance &#x3D; numTokensSellToAddToLiquidity;\n            &#x2F;&#x2F;add liquidity\n            swapAndLiquify(contractTokenBalance);\n        &#125;\n        \n        &#x2F;&#x2F;indicates if fee should be deducted from transfer\n        bool takeFee &#x3D; true;\n        \n        &#x2F;&#x2F;if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to])&#123;\n            takeFee &#x3D; false;\n        &#125;\n        \n        &#x2F;&#x2F;transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from,to,amount,takeFee);\n    &#125;\n    <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个函数首先校验转账账号以及转账金额，然后获取当前合约的safemoon余额，如果大于numTokensSellToAddToLiquidity并且转账发起人不是uniswap的交易对，并且当前允许添加流动性，接下来就会进入添加流动性的流程。添加完流动性后，进入_tokenTransfer方法继续执行转账。</p>\n<h3 id=\"4-2-swapAndLiquify\"><a href=\"#4-2-swapAndLiquify\" class=\"headerlink\" title=\"4.2.swapAndLiquify\"></a>4.2.swapAndLiquify</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap &#123;\n        &#x2F;&#x2F; split the contract balance into halves\n        uint256 half &#x3D; contractTokenBalance.div(2);\n        uint256 otherHalf &#x3D; contractTokenBalance.sub(half);\n \n        &#x2F;&#x2F; capture the contract&#39;s current ETH balance.\n        &#x2F;&#x2F; this is so that we can capture exactly the amount of ETH that the\n        &#x2F;&#x2F; swap creates, and not make the liquidity event include any ETH that\n        &#x2F;&#x2F; has been manually sent to the contract\n        uint256 initialBalance &#x3D; address(this).balance;\n \n        &#x2F;&#x2F; swap tokens for ETH\n        swapTokensForEth(half); &#x2F;&#x2F; &lt;- this breaks the ETH -&gt; HATE swap when swap+liquify is triggered\n \n        &#x2F;&#x2F; how much ETH did we just swap into?\n        uint256 newBalance &#x3D; address(this).balance.sub(initialBalance);\n \n        &#x2F;&#x2F; add liquidity to uniswap\n        addLiquidity(otherHalf, newBalance);\n        \n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    &#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个函数用于添加流动性。首先将传入的数量对半分，然后记录当前合约的ETH数量，然后调用<code>swapTokensForEth</code>将一半的<code>safemoon</code>转换成<code>ETH</code>，通过最新余额和原来的余额，计算出这次<code>swap的ETH数量newBalance</code>，最后调用<code>addLiquidity</code>添加流动性<code>（Safemonn-ETH币对）</code>。</p>\n<h3 id=\"4-3-swapTokensForEth\"><a href=\"#4-3-swapTokensForEth\" class=\"headerlink\" title=\"4.3 swapTokensForEth\"></a>4.3 swapTokensForEth</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function swapTokensForEth(uint256 tokenAmount) private &#123;\n        &#x2F;&#x2F; generate the uniswap pair path of token -&gt; weth\n        address[] memory path &#x3D; new address[](2);\n        path[0] &#x3D; address(this);\n        path[1] &#x3D; uniswapV2Router.WETH();\n \n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n \n        &#x2F;&#x2F; make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, &#x2F;&#x2F; accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n    &#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先构建一个交易路径：<code>[Safemonn ,uniswapV2Router.WETH()]</code>，然后授权给<code>uniswapV2Router</code>一定额度，最终调用<code>uniswapV2Router</code>的<code>swapExactTokensForETHSupportingFeeOnTransferTokens</code>方法执行兑换。注意，这里必须使用<code>swapExactTokensForETHSupportingFeeOnTransferTokens</code>这个方法，因为执行兑换的时候会执行<code>transfer</code>会收手续费，这个方法是<code>uniswap</code>专门给有手续费的币开发的。</p>\n<h3 id=\"4-4-addLiquidity\"><a href=\"#4-4-addLiquidity\" class=\"headerlink\" title=\"4.4 addLiquidity\"></a>4.4 addLiquidity</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private &#123;\n        &#x2F;&#x2F; approve token transfer to cover all possible scenarios\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n \n        &#x2F;&#x2F; add the liquidity\n        uniswapV2Router.addLiquidityETH&#123;value: ethAmount&#125;(\n            address(this),\n            tokenAmount,\n            0, &#x2F;&#x2F; slippage is unavoidable\n            0, &#x2F;&#x2F; slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个方法用于添加流动性，添加流动性本质是将<code>Safemoon和ETH都转给uniswapV2Router</code>，然后获得流动性代币的过程。这里首先授权<code>uniswapV2Router</code>一定的Safemoon额度，然后调用 <code>uniswapV2Router.addLiquidityETH</code>添加流动性。</p>\n<h3 id=\"4-5-tokenTransfer\"><a href=\"#4-5-tokenTransfer\" class=\"headerlink\" title=\"4.5 _tokenTransfer\"></a>4.5 _tokenTransfer</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private &#123;\n        if(!takeFee)\n            removeAllFee();\n        \n        if (_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n            _transferFromExcluded(sender, recipient, amount);\n        &#125; else if (!_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n            _transferToExcluded(sender, recipient, amount);\n        &#125; else if (!_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n            _transferStandard(sender, recipient, amount);\n        &#125; else if (_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n            _transferBothExcluded(sender, recipient, amount);\n        &#125; else &#123;\n            _transferStandard(sender, recipient, amount);\n        &#125;\n        \n        if(!takeFee)\n            restoreAllFee();\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个方法是实际的转账，如果takeFee为<code>false</code>，也就是不收手续费，首先会通过<code>removeAllFee</code>将手续费相关参数置零，最后通过<code>restoreAllFee</code>恢复。中间部分根据是否参与分红，分成四种情况：</p>\n<ul>\n<li><p>1、sender和recipient都不参加分红，这时候走_transferBothExcluded</p>\n</li>\n<li><p>2、sender不参加，recipient参加，这时候走_transferFromExcluded</p>\n</li>\n<li><p>3、sender参加，recipient不参加，这时候走_transferToExcluded</p>\n</li>\n<li><p>4、都参加，这时候走_transferStandard，默认用户都走这个</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getValues(tAmount);\n        _tOwned[sender] &#x3D; _tOwned[sender].sub(tAmount);\n        _rOwned[sender] &#x3D; _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] &#x3D; _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] &#x3D; _rOwned[recipient].add(rTransferAmount);        \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);&#125;\n    \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getValues(tAmount);\n        _rOwned[sender] &#x3D; _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] &#x3D; _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n \n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getValues(tAmount);\n        _rOwned[sender] &#x3D; _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] &#x3D; _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] &#x3D; _rOwned[recipient].add(rTransferAmount);           \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n \n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getValues(tAmount);\n        _tOwned[sender] &#x3D; _tOwned[sender].sub(tAmount);\n        _rOwned[sender] &#x3D; _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] &#x3D; _rOwned[recipient].add(rTransferAmount);   \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这四个<code>transfer</code>方法首先都会通过<code>_getValues</code>获取本次转账的参数，然后进行t值和r值的加减。然后扣除转账手续费和流动性手续费。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) &#123;\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) &#x3D; _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) &#x3D; _getRValues(tAmount, tFee, tLiquidity, _getRate());\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n    &#125;\n \n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) &#123;\n        uint256 tFee &#x3D; calculateTaxFee(tAmount);\n        uint256 tLiquidity &#x3D; calculateLiquidityFee(tAmount);\n        uint256 tTransferAmount &#x3D; tAmount.sub(tFee).sub(tLiquidity);\n        return (tTransferAmount, tFee, tLiquidity);\n    &#125;\n \n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) &#123;\n        uint256 rAmount &#x3D; tAmount.mul(currentRate);\n        uint256 rFee &#x3D; tFee.mul(currentRate);\n        uint256 rLiquidity &#x3D; tLiquidity.mul(currentRate);\n        uint256 rTransferAmount &#x3D; rAmount.sub(rFee).sub(rLiquidity);\n        return (rAmount, rTransferAmount, rFee);\n    &#125;\n    \n    function _getRate() private view returns(uint256) &#123;\n        (uint256 rSupply, uint256 tSupply) &#x3D; _getCurrentSupply();\n        return rSupply.div(tSupply);\n    &#125;\n \n    function _getCurrentSupply() private view returns(uint256, uint256) &#123;\n        uint256 rSupply &#x3D; _rTotal;\n        uint256 tSupply &#x3D; _tTotal;      \n        for (uint256 i &#x3D; 0; i &lt; _excluded.length; i++) &#123;\n            if (_rOwned[_excluded[i]] &gt; rSupply || _tOwned[_excluded[i]] &gt; tSupply) return (_rTotal, _tTotal);\n            rSupply &#x3D; rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply &#x3D; tSupply.sub(_tOwned[_excluded[i]]);\n        &#125;\n        if (rSupply &lt; _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    &#125;\n    \n    function calculateTaxFee(uint256 _amount) private view returns (uint256) &#123;\n        return _amount.mul(_taxFee).div(\n            10**2\n        );\n    &#125;\n \n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) &#123;\n        return _amount.mul(_liquidityFee).div(\n            10**2\n        );\n    &#125;\n    \n    function _reflectFee(uint256 rFee, uint256 tFee) private &#123;\n        _rTotal &#x3D; _rTotal.sub(rFee);\n        _tFeeTotal &#x3D; _tFeeTotal.add(tFee);\n    &#125;\n    \n    function _takeLiquidity(uint256 tLiquidity) private &#123;\n        uint256 currentRate &#x3D;  _getRate();\n        uint256 rLiquidity &#x3D; tLiquidity.mul(currentRate);\n        _rOwned[address(this)] &#x3D; _rOwned[address(this)].add(rLiquidity);\n        if(_isExcluded[address(this)])\n            _tOwned[address(this)] &#x3D; _tOwned[address(this)].add(tLiquidity);\n    &#125;\n    \n    function balanceOf(address account) public view override returns (uint256) &#123;\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    &#125;\n    \n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) &#123;\n        require(rAmount &lt;&#x3D; _rTotal, &quot;Amount must be less than total reflections&quot;);\n        uint256 currentRate &#x3D;  _getRate();\n        return rAmount.div(currentRate);\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>_getValues</code>先获取t值，再获取r值。普通分红用户只会用到r值，这个值其实就是用户的盘子数量，t值永远是0。而不参与分红的用户，除了r值正常变化，t值也会变化，如果别人转给他，t值就增加，如果他转给别人t值就减少。普通分红用户t值为0，当管理员把用户设置为非分红用户的时候，t值会通过用户当前的r值进行换算，而再次设置为分红用户的时候，t值又会清零。通过t值和r值的分离，实现了分红用户和非分红用户的分离。</p>\n</li>\n</ul>\n<p>在执行transfer的时候，会调用_reflectFee，这个会减少_rTotal，也就是打碎一些盘子的数量。也会调用_takeLiquidity，这个是转移流动性手续费，仅仅是盘子的转移，不会打碎盘子。</p>\n<p>而balanceOf的实现如下：<br><code>rAmount.div(rSupply.div(tSupply)) ====&gt; rAmount * tSupply / rSupply</code></p>\n<p><code>tSupply</code>是排除非分红的用户的总蛋糕数，<code>rSupply</code>是排除非分红用户的总盘子数，当全是分红用户的时候，<code>tSupply</code>就是<code>_tTotal</code>，<code>rSupply</code>就是<code>_rTotal</code>。</p>\n<p>当别人转账的时候打碎了一部分盘子，这导致<code>rSupply</code>减少，而总蛋糕<code>tSupply</code>不变，用户自己持有的盘子<code>rAmount</code>也不变，这样就导致自己分到的蛋糕总量增加了，这就是分红的原理。</p>\n<h1 id=\"5、通缩分红币的潜在问题\"><a href=\"#5、通缩分红币的潜在问题\" class=\"headerlink\" title=\"5、通缩分红币的潜在问题\"></a>5、通缩分红币的潜在问题</h1><ol>\n<li><p>由于每次转账都会销毁手续费，当剩余总量小于手续费得时候，就无法转账了。</p>\n</li>\n<li><p>这种币把balanceOf的逻辑改了，导致即使用户不进行任何操作，balanceOf在不同时刻返回的值是不一样的。这在一些强依赖balanceOf的的合约中就会出现问题，比如sushiswap如果使用通缩币进行质押，就可能导致计算奖励出现问题。因此，智能合约开发者在进行开发的时候，需要考虑下通缩币的逻辑，避免出现不必要的漏洞。</p>\n</li>\n<li><p>这个币强依赖uniswap，一旦uniswap升级或者下线，该币可能会受到影响。</p>\n</li>\n</ol>\n","text":"1、Safemoon原理Safemoon是一种通缩分红币，通缩指的是每次转账都会收取一定手续费，这些手续费会直接销毁，进而导致总量的通缩。分红指的是，用户的余额会随着其他用户转账而增加。 Safemoon的基本原理用一个比喻来说就是，将一块固定蛋糕（_tTotal）分给总量会变化...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Solidity","slug":"Solidity","count":5,"path":"api/categories/Solidity.json"}],"tags":[{"name":"区块链","slug":"区块链","count":13,"path":"api/tags/区块链.json"},{"name":"Solidity","slug":"Solidity","count":5,"path":"api/tags/Solidity.json"},{"name":"智能合约","slug":"智能合约","count":2,"path":"api/tags/智能合约.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1%E3%80%81Safemoon%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1、Safemoon原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2%E3%80%81-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2、 数据结构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3、构造函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4、核心方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-transfer\"><span class=\"toc-text\">4.1 _transfer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-swapAndLiquify\"><span class=\"toc-text\">4.2.swapAndLiquify</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-swapTokensForEth\"><span class=\"toc-text\">4.3 swapTokensForEth</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-addLiquidity\"><span class=\"toc-text\">4.4 addLiquidity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-tokenTransfer\"><span class=\"toc-text\">4.5 _tokenTransfer</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5%E3%80%81%E9%80%9A%E7%BC%A9%E5%88%86%E7%BA%A2%E5%B8%81%E7%9A%84%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">5、通缩分红币的潜在问题</span></a></li></ol>","author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"浅谈NFT的元数据标准","uid":"c818a12081dd186c3b840bc9579f9407","slug":"浅谈NFT的元数据标准/index","date":"2022-03-19T14:38:20.000Z","updated":"2022-03-24T16:28:07.792Z","comments":true,"path":"api/articles/浅谈NFT的元数据标准/index.json","keywords":null,"cover":[],"text":"前言为OpenSea等平台提供资产元数据可以为数字资产提供丰富的数据并轻松地在应用程序中显示它们。给定智能合约上的数字资产通常仅由唯一标识符（例如，ERC721 中的 token_id表示，因此元数据允许这些资产具有其他属性，例如名称、描述和图像。 实现令牌URI为了让 Open...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"NFT","slug":"NFT","count":1,"path":"api/categories/NFT.json"}],"tags":[{"name":"区块链","slug":"区块链","count":13,"path":"api/tags/区块链.json"},{"name":"百科","slug":"百科","count":2,"path":"api/tags/百科.json"},{"name":"NFT","slug":"NFT","count":1,"path":"api/tags/NFT.json"}],"author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}}},"next_post":{"title":"详解分红其他代币，添加流动性合约","uid":"bb3bf222bcca42dfaadd6e15dbdfbacd","slug":"详解分红其他代币，添加流动性合约/index","date":"2022-03-18T15:55:32.000Z","updated":"2022-03-24T16:28:03.853Z","comments":true,"path":"api/articles/详解分红其他代币，添加流动性合约/index.json","keywords":null,"cover":null,"text":"contract Token is ERC20, Ownable &#123; using SafeMath for uint256; IUniswapV2Router02 public uniswapV2Router; address public immutable unis...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"Solidity","slug":"Solidity","count":5,"path":"api/categories/Solidity.json"}],"tags":[{"name":"区块链","slug":"区块链","count":13,"path":"api/tags/区块链.json"},{"name":"Solidity","slug":"Solidity","count":5,"path":"api/tags/Solidity.json"},{"name":"智能合约","slug":"智能合约","count":2,"path":"api/tags/智能合约.json"}],"author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}}}}