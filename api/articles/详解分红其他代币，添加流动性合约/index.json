{"title":"详解分红其他代币，添加流动性合约","uid":"bb3bf222bcca42dfaadd6e15dbdfbacd","slug":"详解分红其他代币，添加流动性合约/index","date":"2022-03-18T15:55:32.000Z","updated":"2022-03-24T16:28:03.853Z","comments":true,"path":"api/articles/详解分红其他代币，添加流动性合约/index.json","keywords":null,"cover":null,"content":"<pre class=\"line-numbers language-none\"><code class=\"language-none\">contract Token is ERC20, Ownable &#123;\n    using SafeMath for uint256;\n \n    IUniswapV2Router02 public uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    bool private swapping;\n    bool public swapEnabled &#x3D; true;\n    DividendTracker public dividendTracker;          &#x2F;&#x2F;分红对象\n    address public liquidityWallet;          &#x2F;&#x2F;流动性钱包\n    address private _marketingWalletAddress;         &#x2F;&#x2F;营销钱包，收手续费的\n    address public deadWallet &#x3D; 0x000000000000000000000000000000000000dEaD;        &#x2F;&#x2F;销毁钱包，也就是把钱打进这里。\n    uint256 public maxSellTransactionAmount &#x3D; 10000000000000 * (10 ** 16);              &#x2F;&#x2F;最大卖出数量\n    uint256 public swapTokensAtAmount &#x3D; 1000000000 * (10 ** 18);                      \n    uint256  BNBRewardsFee &#x3D; 7;                                                     &#x2F;&#x2F;分红每次交易百分之7的bnb\n    uint256  liquidityFee &#x3D; 3;                                                      &#x2F;&#x2F;流动性手续费\n    uint256  marketingFee &#x3D; 4;                                                       &#x2F;&#x2F;营销钱包收进的手续费\n \n    uint256 public totalFees &#x3D; BNBRewardsFee.add(liquidityFee).add(marketingFee);               &#x2F;&#x2F;总手续费用\n    uint256 public tradingEnabledTimestamp &#x3D; 1628258400; &#x2F;&#x2F;10:00pm                     &#x2F;&#x2F;2021-08-06 22:00:00的时间戳          \n \n    &#x2F;&#x2F; sells have fees of 12 and 6 (10 * 1.2 and 5 * 1.2)           \n    uint256 public immutable sellFeeIncreaseFactor &#x3D; 120;\n \n    &#x2F;&#x2F; use by default 300,000 gas to process auto-claiming dividends\n    &#x2F;&#x2F;默认使用300000 gas 处理自动申请分红\n    uint256 public gasForProcessing &#x3D; 300000;\n \n    mapping(address &#x3D;&gt; bool) private _isExcludedFromFees;          &#x2F;&#x2F;判断是否此账号需要手续费，true为不需要手续费\n    mapping(address &#x3D;&gt; bool) public automatedMarketMakerPairs;        &#x2F;&#x2F;判断是否卖出\n    mapping(address &#x3D;&gt; bool) public _isBlacklisted;    &#x2F;&#x2F;是否是黑名单,true表示这个地址是黑名单\n \n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);     &#x2F;&#x2F;监听更新分红跟踪事件\n \n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);            &#x2F;&#x2F;监听更新周边路由事件\n \n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\n \n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n \n    event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);\n \n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n \n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n    );\n \n    event SendDividends(\n        uint256 tokensSwapped,\n        uint256 amount\n    );\n \n    event ProcessedDividendTracker(\n        uint256 iterations,\n        uint256 claims,\n        uint256 lastProcessedIndex,\n        bool indexed automatic,\n        uint256 gas,\n        address indexed processor\n    );\n \n    constructor(address _ma) public ERC20(&quot;man&quot;, &quot;man&quot;) &#123;\n \n        dividendTracker &#x3D; new DividendTracker();   \n \n        liquidityWallet &#x3D; owner();          &#x2F;&#x2F;流动性钱包&#x3D;msg.sender.也就是部署这个合约的钱包\n        _marketingWalletAddress &#x3D; _ma;          &#x2F;&#x2F;营销钱包&#x3D;_ma\n        \n        IUniswapV2Router02 _uniswapV2Router &#x3D; IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);  &#x2F;&#x2F;构造测试网的_uniswapV2Router对象\n        &#x2F;&#x2F; Create a uniswap pair for this new token\n        &#x2F;&#x2F;为这个新币创建一个uniswap pair  也就是uniswap的核心合约\n        address _uniswapV2Pair &#x3D; IUniswapV2Factory(_uniswapV2Router.factory())     &#x2F;&#x2F;factory 返回地址也就是0x9Ac64那个\n        .createPair(address(this), _uniswapV2Router.WETH());   &#x2F;&#x2F;createPair创建交易对 .该函数接受任意两个代币地址为参数，用来创建一个新的交易对合约并返回新合约的地址。\n        &#x2F;&#x2F;createPair的第一个地址是这个合约的地址，第二个地址是0x9Ac64Cc6e地址\n        uniswapV2Router &#x3D; _uniswapV2Router;     \n        uniswapV2Pair &#x3D; _uniswapV2Pair;\n \n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\n \n        &#x2F;&#x2F; exclude from receiving dividends  不在分红范围内的\n        dividendTracker.excludeFromDividends(address(dividendTracker));            \n        dividendTracker.excludeFromDividends(address(this));                 &#x2F;&#x2F;这个合约地址\n        dividendTracker.excludeFromDividends(owner());                        &#x2F;&#x2F;msg.sender地址,也就铸币接收者\n        dividendTracker.excludeFromDividends(deadWallet);                     &#x2F;&#x2F;销毁地址\n        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\n \n        &#x2F;&#x2F; exclude from paying fees or having max transaction amount 排除支付费用或拥有最大交易金额\n        excludeFromFees(liquidityWallet, true);        &#x2F;&#x2F;排除流动性钱包的支付手续费和最大交易金额\n        excludeFromFees(address(this), true);              &#x2F;&#x2F;排除铸币钱包的支付手续费和最大交易金额\n        excludeFromFees(_marketingWalletAddress, true);      &#x2F;&#x2F;排除营销钱包的支付手续费和最大交易金额\n \n        _mint(owner(), 10000000000000 * (10 ** 18));            &#x2F;&#x2F;铸币给msg.ssender于10000000000000个币；\n    &#125;                  \n    &#x2F;&#x2F;外部合约调用接收方法\n    receive() external payable &#123;\n \n    &#125;\n    &#x2F;&#x2F;改变最大卖出额度\n    function changeMaxSellTransactionAmount(uint amount) external onlyOwner &#123;\n        maxSellTransactionAmount &#x3D; amount;\n    &#125;\n    &#x2F;&#x2F;更新分红合约对象\n    function updateDividendTracker(address newAddress) public onlyOwner &#123;\n        &#x2F;&#x2F;如果新地址&#x3D;&#x3D;adaddress(ddividendTracker)则跳出函数\n        require(newAddress !&#x3D; address(dividendTracker), &quot;RedCheCoin The dividend tracker already has that address&quot;);\n        \n        DividendTracker newDividendTracker &#x3D; DividendTracker(payable(newAddress));\n \n        require(newDividendTracker.owner() &#x3D;&#x3D; address(this), &quot;RedCheCoin The new dividend tracker must be owned by the RedCheCoin token contract&quot;);\n \n        newDividendTracker.excludeFromDividends(address(newDividendTracker));       &#x2F;&#x2F;newDividendTracker地址不分红\n        newDividendTracker.excludeFromDividends(address(this));                    &#x2F;&#x2F;这个合约地址不分红\n        newDividendTracker.excludeFromDividends(owner());                           &#x2F;&#x2F;msg.sender地址\n        newDividendTracker.excludeFromDividends(address(uniswapV2Router));          &#x2F;&#x2F;代币对地址\n \n        emit UpdateDividendTracker(newAddress, address(dividendTracker));   \n \n        dividendTracker &#x3D; newDividendTracker;                     \n    &#125;\n    &#x2F;&#x2F;更新周边路由事件\n    function updateUniswapV2Router(address newAddress) public onlyOwner &#123;\n        require(newAddress !&#x3D; address(uniswapV2Router), &quot;RedCheCoin The router already has that address&quot;);  &#x2F;&#x2F;如果新的地址是原来的周边路由地址则跳出\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));         \n        uniswapV2Router &#x3D; IUniswapV2Router02(newAddress);      &#x2F;&#x2F;把新的周边路由地址赋值给旧的\n    &#125;\n    &#x2F;&#x2F;排除手续费\n    function excludeFromFees(address account, bool excluded) public onlyOwner &#123;   &#x2F;&#x2F;onlyOwner判断是不是msg.sender\n        require(_isExcludedFromFees[account] !&#x3D; excluded, &quot;RedCheCoin Account is already the value of &#39;excluded&#39;&quot;);   &#x2F;&#x2F;如果已经排除就跳出\n        _isExcludedFromFees[account] &#x3D; excluded;                 &#x2F;&#x2F;设置是否排除的布尔值\n \n        emit ExcludeFromFees(account, excluded);\n    &#125;\n    &#x2F;&#x2F;排除多个地址账号的手续费\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner &#123;\n        for (uint256 i &#x3D; 0; i &lt; accounts.length; i++) &#123;\n            _isExcludedFromFees[accounts[i]] &#x3D; excluded;\n        &#125;\n \n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\n    &#125;\n    &#x2F;&#x2F;设置lp流动性地址\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner &#123;\n        require(pair !&#x3D; uniswapV2Pair, &quot;RedCheCoin The PancakeSwap pair cannot be removed from automatedMarketMakerPairs&quot;);\n        \n        _setAutomatedMarketMakerPair(pair, value);\n    &#125;\n    &#x2F;&#x2F;设置黑名单地址\n    function blacklistAddress(address account, bool value) external onlyOwner &#123;\n        _isBlacklisted[account] &#x3D; value;   &#x2F;&#x2F;如果是true就是黑名单\n    &#125;\n \n    function _setAutomatedMarketMakerPair(address pair, bool value) private &#123;\n        &#x2F;&#x2F;做一个判断如果已经赋了布尔值就跳出函数\n        require(automatedMarketMakerPairs[pair] !&#x3D; value, &quot;RedCheCoin Automated market maker pair is already set to that value&quot;);\n        automatedMarketMakerPairs[pair] &#x3D; value;     \n        if (value) &#123;\n            dividendTracker.excludeFromDividends(pair);\n        &#125;\n \n        emit SetAutomatedMarketMakerPair(pair, value);\n    &#125;\n \n    &#x2F;&#x2F;更新流动池钱包\n    function updateLiquidityWallet(address newLiquidityWallet) public onlyOwner &#123;\n        require(newLiquidityWallet !&#x3D; liquidityWallet, &quot;RedCheCoin The liquidity wallet is already this address&quot;);\n        _isExcludedFromFees[newLiquidityWallet] &#x3D; true;          &#x2F;&#x2F;设置新的流动池钱包\n        emit LiquidityWalletUpdated(newLiquidityWallet, liquidityWallet);        \n        liquidityWallet &#x3D; newLiquidityWallet;          &#x2F;&#x2F;旧流动池钱包&#x3D;新流动池钱包             \n    &#125;\n    &#x2F;&#x2F;更新营销钱包\n    function updateMarketingWallet(address newMarkting) public onlyOwner &#123;\n        require(newMarkting !&#x3D; _marketingWalletAddress, &quot;RedCheCoin The Markting wallet is already this address&quot;);  &#x2F;&#x2F;如果新营销钱包&#x3D;旧营销钱包则跳出\n        _isExcludedFromFees[newMarkting] &#x3D; true;                                                    &#x2F;&#x2F;设置新营销钱包除外手续费\n        _marketingWalletAddress &#x3D; newMarkting;                                                       &#x2F;&#x2F;旧营销钱包&#x3D;新营销钱包\n    &#125;\n    &#x2F;&#x2F;更新gas费用\n    function updateGasForProcessing(uint256 newValue) public onlyOwner &#123;\n        require(newValue &gt;&#x3D; 200000 &amp;&amp; newValue &lt;&#x3D; 500000, &quot;RedCheCoin gasForProcessing must be between 200,000 and 500,000&quot;);    &#x2F;&#x2F;非200000到500000则跳出\n        require(newValue !&#x3D; gasForProcessing, &quot;RedCheCoin Cannot update gasForProcessing to same value&quot;);       &#x2F;&#x2F;如果和旧的值一样就跳出\n        emit GasForProcessingUpdated(newValue, gasForProcessing);   \n        gasForProcessing &#x3D; newValue;                                      &#x2F;&#x2F;旧的gas&#x3D;新的gas\n    &#125;\n    \n    function updateClaimWait(uint256 claimWait) external onlyOwner &#123;\n        dividendTracker.updateClaimWait(claimWait);\n    &#125;\n \n    function getClaimWait() external view returns (uint256) &#123;\n        return dividendTracker.claimWait();\n    &#125;\n \n    function getTotalDividendsDistributed() external view returns (uint256) &#123;\n        return dividendTracker.totalDividendsDistributed();\n    &#125;\n    &#x2F;&#x2F;block.timestamp (uint):当前块的时间戳\n    &#x2F;&#x2F;此函数通过到达开盘时间才能交易\n    function getTradingIsEnabled() public view returns (bool) &#123;\n        return block.timestamp &gt;&#x3D; tradingEnabledTimestamp;\n    &#125;\n    &#x2F;&#x2F;返回是否除外手续费的布尔值\n    function isExcludedFromFees(address account) public view returns (bool) &#123;\n        return _isExcludedFromFees[account];\n    &#125;\n    &#x2F;&#x2F;应该是取回分红？？？\n    function withdrawableDividendOf(address account) public view returns (uint256) &#123;\n        return dividendTracker.withdrawableDividendOf(account);\n    &#125;\n    &#x2F;&#x2F;取的分红的地址\n    function dividendTokenBalanceOf(address account) public view returns (uint256) &#123;\n        return dividendTracker.balanceOf(account);\n    &#125;\n    \n    function getAccountDividendsInfo(address account)\n    external view returns (\n        address,\n        int256,\n        int256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256) &#123;\n        return dividendTracker.getAccount(account);\n    &#125;\n \n    function getAccountDividendsInfoAtIndex(uint256 index)\n    external view returns (\n        address,\n        int256,\n        int256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256) &#123;\n        return dividendTracker.getAccountAtIndex(index);\n    &#125;\n \n    function processDividendTracker(uint256 gas) external &#123;\n        (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) &#x3D; dividendTracker.process(gas);\n        emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\n    &#125;\n \n    function claim() external &#123;\n        dividendTracker.processAccount(msg.sender, false);\n    &#125;\n \n    function getLastProcessedIndex() external view returns (uint256) &#123;\n        return dividendTracker.getLastProcessedIndex();\n    &#125;\n \n    function getNumberOfDividendTokenHolders() external view returns (uint256) &#123;\n        return dividendTracker.getNumberOfTokenHolders();\n    &#125;\n    &#x2F;&#x2F;交易函数\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override &#123;\n        require(from !&#x3D; address(0), &quot;ERC20: transfer from the zero address&quot;);    &#x2F;&#x2F;如果发送方是空地址则跳出\n        require(!_isBlacklisted[from], &#39;Blacklisted address&#39;);                        &#x2F;&#x2F;如果接收方是空地址则跳出\n \n \n        if (amount &#x3D;&#x3D; 0) &#123;                              &#x2F;&#x2F;转0个币则直接转\n            super._transfer(from, to, 0);\n            return;\n        &#125;\n \n        if (swapping) &#123;\n            super._transfer(from, to, amount);\n            return;\n        &#125;\n \n        bool isMng &#x3D; _isExcludedFromFees[from] || _isExcludedFromFees[to];      &#x2F;&#x2F;判断是否非手续费\n        bool tradingIsEnabled &#x3D; getTradingIsEnabled();               &#x2F;&#x2F;判断是到开盘时间，true表示到了          \n \n        &#x2F;&#x2F; add liqiud\n        if (!tradingIsEnabled) &#123;                  &#x2F;&#x2F;判断是否到开盘时间\n            require(isMng, &quot;This account cannot send tokens until trading is enabled&quot;);   &#x2F;&#x2F;判断是否添加流动池账号，如果不是则跳出此函数\n        &#125;\n \n        if (\n            tradingIsEnabled &amp;&amp;                  &#x2F;&#x2F;到达开盘时间\n            balanceOf(uniswapV2Pair) &gt; 0 &amp;&amp;                 &#x2F;&#x2F;流动池大于0\n            automatedMarketMakerPairs[from] &amp;&amp;         &#x2F;&#x2F;li流动性可用          \n            !isMng &amp;&amp;                           &#x2F;&#x2F;是否排除手续费\n            tradingIsEnabled &amp;&amp;                         \n            block.timestamp &lt;&#x3D; tradingEnabledTimestamp + 9 seconds) &#123;  &#x2F;&#x2F;当前块的时间戳小于等于 可交易时间戳+9秒。如果是在9秒内抢到\n            addBot(to);                                 &#x2F;&#x2F;则添加黑名单\n        &#125;\n \n        if (\n            !swapping &amp;&amp;                        \n        from !&#x3D; address(uniswapV2Router) &amp;&amp;\n        to !&#x3D; address(uniswapV2Router) &amp;&amp;\n        !isMng\n        ) &#123;\n            require(amount &lt;&#x3D; maxSellTransactionAmount, &quot;Sell transfer amount exceeds the maxSellTransactionAmount.&quot;);  &#x2F;&#x2F;判断是否超出最大可卖出数量\n        &#125;\n \n        uint256 contractTokenBalance &#x3D; balanceOf(address(this));          &#x2F;&#x2F;获得该代币余额\n \n        bool canSwap &#x3D; contractTokenBalance &gt;&#x3D; swapTokensAtAmount;        &#x2F;&#x2F;是否可以交易\n \n        if (\n            swapEnabled &amp;&amp;\n            canSwap &amp;&amp;\n            !swapping &amp;&amp;\n            !automatedMarketMakerPairs[from] &amp;&amp;\n            from !&#x3D; liquidityWallet &amp;&amp;\n            to !&#x3D; liquidityWallet\n        ) &#123;\n            swapping &#x3D; true;\n \n            uint256 marketingTokens &#x3D; contractTokenBalance.mul(marketingFee).div(totalFees);    &#x2F;&#x2F;营销钱包的币&#x3D;该合约代币余额*营销手续费&#x2F;总手续费\n            swapAndSendToFee(marketingTokens);                                          &#x2F;&#x2F;发送给营销钱包手续费用的币\n \n            uint256 swapTokens &#x3D; contractTokenBalance.mul(liquidityFee).div(totalFees);               &#x2F;&#x2F;添加流动性的币&#x3D;该合约代币余额*流动性手续费&#x2F;总手续费\n            swapAndLiquify(swapTokens);                                    &#x2F;&#x2F;添加流动性\n \n            uint256 sellTokens &#x3D; balanceOf(address(this));                                &#x2F;&#x2F;卖的币&#x3D;该合约代币余额\n            swapAndSendDividends(sellTokens);                                           &#x2F;&#x2F;分红卖的币\n            swapping &#x3D; false;\n        &#125;\n \n \n        bool takeFee &#x3D; !swapping;                   \n \n        &#x2F;&#x2F; if any account belongs to _isExcludedFromFee account then remove the fee 如果任何帐户属于_isExcludedFromFee帐户，那么删除费用\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) &#123;\n            takeFee &#x3D; false;                                   &#x2F;&#x2F;设置无手续费\n        &#125;\n \n        if (takeFee) &#123;\n            uint256 fees &#x3D; amount.mul(totalFees).div(100);           &#x2F;&#x2F;手续费&#x3D;币数量*总手续费&#x2F;100;\n \n            &#x2F;&#x2F; if sell, multiply by 1.2\n            if (automatedMarketMakerPairs[to]) &#123;\n                fees &#x3D; fees.mul(sellFeeIncreaseFactor).div(100);            &#x2F;&#x2F;如果卖出的话手续费*1.2\n            &#125;\n \n            amount &#x3D; amount.sub(fees);             &#x2F;&#x2F;币数量&#x3D;币数量-手续费\n \n            super._transfer(from, address(this), fees);            &#x2F;&#x2F;转账msg.sender到合约地址，手续费用的币\n        &#125;\n \n        super._transfer(from, to, amount);                  &#x2F;&#x2F;转账实际已经扣除手续的币\n \n        try dividendTracker.setBalance(payable(from), balanceOf(from)) &#123;&#125; catch &#123;&#125;\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) &#123;&#125; catch &#123;&#125;\n \n        if (!swapping) &#123;\n            uint256 gas &#x3D; gasForProcessing;       \n \n            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) &#123;\n                emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\n            &#125;\n            catch &#123;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;设置是否可交易\n    function setSwapEnabled(bool _enabled) external onlyOwner &#123;\n        swapEnabled &#x3D; _enabled;\n    &#125;\n    &#x2F;&#x2F;设置手续费用\n    function setF(uint _BNBRewardsFee, uint _liquidityFee, uint _marketingFee) external onlyOwner &#123;\n        BNBRewardsFee &#x3D; _BNBRewardsFee;\n        liquidityFee &#x3D; _liquidityFee;\n        marketingFee &#x3D; _marketingFee;\n    &#125;\n    &#x2F;&#x2F;添加黑名单的函数\n    function addBot(address recipient) private &#123;\n        if (!_isBlacklisted[recipient]) _isBlacklisted[recipient] &#x3D; true;\n    &#125;\n    &#x2F;&#x2F;发送给营销钱包手续费用\n    function swapAndSendToFee(uint256 tokens) private &#123;\n        uint256 initialBNBBalance &#x3D; address(this).balance;\n        swapTokensForEth(tokens);   \n        uint256 newBalance &#x3D; address(this).balance.sub(initialBNBBalance);\n        payable(_marketingWalletAddress).transfer(newBalance);\n    &#125;\n    &#x2F;&#x2F;交易流动性\n    function swapAndLiquify(uint256 tokens) private &#123;\n        &#x2F;&#x2F; split the contract balance into halves 把该合同余额平分，分成一半\n        uint256 half &#x3D; tokens.div(2);\n        uint256 otherHalf &#x3D; tokens.sub(half);\n \n        &#x2F;&#x2F; capture the contract&#39;s current ETH balance.   获取合同当前ETH余额。\n        &#x2F;&#x2F; this is so that we can capture exactly the amount of ETH that the   这样我们就能准确地捕获ETH的数量\n        &#x2F;&#x2F; swap creates, and not make the liquidity event include any ETH that    交换产生，而不使流动性事件包括任何ETH\n        &#x2F;&#x2F; has been manually sent to the contract    手动发送给合约地址\n        uint256 initialBalance &#x3D; address(this).balance;\n \n        &#x2F;&#x2F; swap tokens for ETH  ETH交换代币\n        swapTokensForEth(half);\n        &#x2F;&#x2F; &lt;- this breaks the ETH -&gt; HATE swap when swap+liquify is triggered  当swap+liquify被触发时，这会打破ETH -&gt;HATE swap\n \n        &#x2F;&#x2F; how much ETH did we just swap into?   我们刚才换了多少ETH ?\n        uint256 newBalance &#x3D; address(this).balance.sub(initialBalance);\n \n        &#x2F;&#x2F; add liquidity to uniswap      为uniswap增加流动性\n        addLiquidity(otherHalf, newBalance);\n \n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    &#125;\n    &#x2F;&#x2F;交换代币\n    function swapTokensForEth(uint256 tokenAmount) private &#123;\n \n \n        &#x2F;&#x2F; generate the uniswap pair path of token -&gt; weth  生成unswap pair周边合约代币路径 -&gt; 用eth位来表示\n        address[] memory path &#x3D; new address[](2);   \n        path[0] &#x3D; address(this);\n        path[1] &#x3D; uniswapV2Router.WETH();\n \n        _approve(address(this), address(uniswapV2Router), tokenAmount);    \n \n        &#x2F;&#x2F; make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, &#x2F;&#x2F; accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n \n    &#125;\n    &#x2F;&#x2F;添加流动性\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private &#123;\n \n        &#x2F;&#x2F; approve token transfer to cover all possible scenarios      批准代币转账以覆盖所有可能的场景\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n \n        &#x2F;&#x2F; add the liquidity           添加流动性\n        uniswapV2Router.addLiquidityETH&#123;value : ethAmount&#125;(\n            address(this),\n            tokenAmount,\n            0, &#x2F;&#x2F; slippage is unavoidable     &#x2F;&#x2F;滑点是不可避免的\n            0, &#x2F;&#x2F; slippage is unavoidable   &#x2F;&#x2F;滑点是不可避免的\n            liquidityWallet,                     &#x2F;&#x2F;流动性钱包;\n            block.timestamp                  &#x2F;&#x2F;当块的时间戳\n        );\n \n    &#125;\n    &#x2F;&#x2F;交易分红\n    function swapAndSendDividends(uint256 tokens) private &#123;\n        swapTokensForEth(tokens);\n        uint256 dividends &#x3D; address(this).balance;\n        (bool success,) &#x3D; address(dividendTracker).call&#123;value : dividends&#125;(&quot;&quot;);\n \n        if (success) &#123;\n            emit SendDividends(tokens, dividends);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>发射器合约</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; SPDX-License-Identifier: MIT\n \npragma solidity ^0.6.2;\nimport &quot;.&#x2F;Ownable.sol&quot;;\nimport &quot;.&#x2F;DividendPayingToken.sol&quot;;\nimport &quot;.&#x2F;SafeMath.sol&quot;;\nimport &quot;.&#x2F;SafeMathInt.sol&quot;;\nimport &quot;.&#x2F;IterableMapping.sol&quot;;\ncontract DividendTracker is Ownable, DividendPayingToken &#123;\n    using SafeMath for uint256;\n    using SafeMathInt for int256;\n    using IterableMapping for IterableMapping.Map;\n \n    IterableMapping.Map private tokenHoldersMap;\n    uint256 public lastProcessedIndex;\n \n    mapping(address &#x3D;&gt; bool) public excludedFromDividends;\n \n    mapping(address &#x3D;&gt; uint256) public lastClaimTimes;\n \n    uint256 public claimWait;\n    uint256 public immutable minimumTokenBalanceForDividends;\n \n    event ExcludeFromDividends(address indexed account);\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n \n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\n \n    constructor() public DividendPayingToken(&quot;RedCheCoin_Dividend_Tracker&quot;, &quot;RedCheCoin_Dividend_Tracker&quot;) &#123;\n        claimWait &#x3D; 1200;\n        minimumTokenBalanceForDividends &#x3D; 10000 * (10 ** 18);\n        &#x2F;&#x2F;must hold 10000+ tokens\n    &#125;\n \n    function _transfer(address, address, uint256) internal override &#123;\n        require(false, &quot;RedCheCoin_Dividend_Tracker: No transfers allowed&quot;);\n    &#125;\n \n    function withdrawDividend() public override &#123;\n        require(false, &quot;RedCheCoin_Dividend_Tracker: withdrawDividend disabled. Use the &#39;claim&#39; function on the main RedCheCoin contract.&quot;);\n    &#125;\n    &#x2F;&#x2F;此函数用于account形参地址不在分红内\n    function excludeFromDividends(address account) external onlyOwner &#123;\n        &#x2F;&#x2F;false就执行，否则退出此函数，主要检测有没有执行过此函数\n        require(!excludedFromDividends[account]);\n        excludedFromDividends[account] &#x3D; true;      &#x2F;&#x2F;设置分红账号为true\n        _setBalance(account, 0);                    &#x2F;&#x2F;设置目前的余额\n        tokenHoldersMap.remove(account);             \n \n        emit ExcludeFromDividends(account);\n    &#125;\n \n    function updateClaimWait(uint256 newClaimWait) external onlyOwner &#123;\n        require(newClaimWait !&#x3D; claimWait, &quot;RedCheCoin_Dividend_Tracker: Cannot update claimWait to same value&quot;);\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\n        claimWait &#x3D; newClaimWait;\n    &#125;\n \n    function getLastProcessedIndex() external view returns (uint256) &#123;\n        return lastProcessedIndex;\n    &#125;\n \n    function getNumberOfTokenHolders() external view returns (uint256) &#123;\n        return tokenHoldersMap.keys.length;\n    &#125;\n \n \n    function getAccount(address _account)\n    public view returns (\n        address account,\n        int256 index,\n        int256 iterationsUntilProcessed,\n        uint256 withdrawableDividends,\n        uint256 totalDividends,\n        uint256 lastClaimTime,\n        uint256 nextClaimTime,\n        uint256 secondsUntilAutoClaimAvailable) &#123;\n        account &#x3D; _account;\n \n        index &#x3D; tokenHoldersMap.getIndexOfKey(account);\n \n        iterationsUntilProcessed &#x3D; - 1;\n \n        if (index &gt;&#x3D; 0) &#123;\n            if (uint256(index) &gt; lastProcessedIndex) &#123;\n                iterationsUntilProcessed &#x3D; index.sub(int256(lastProcessedIndex));\n            &#125;\n            else &#123;\n                uint256 processesUntilEndOfArray &#x3D; tokenHoldersMap.keys.length &gt; lastProcessedIndex ?\n                tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\n                0;\n \n \n                iterationsUntilProcessed &#x3D; index.add(int256(processesUntilEndOfArray));\n            &#125;\n        &#125;\n \n \n        withdrawableDividends &#x3D; withdrawableDividendOf(account);\n        totalDividends &#x3D; accumulativeDividendOf(account);\n \n        lastClaimTime &#x3D; lastClaimTimes[account];\n \n        nextClaimTime &#x3D; lastClaimTime &gt; 0 ?\n        lastClaimTime.add(claimWait) :\n        0;\n \n        secondsUntilAutoClaimAvailable &#x3D; nextClaimTime &gt; block.timestamp ?\n        nextClaimTime.sub(block.timestamp) :\n        0;\n    &#125;\n \n    function getAccountAtIndex(uint256 index)\n    public view returns (\n        address,\n        int256,\n        int256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256) &#123;\n        if (index &gt;&#x3D; tokenHoldersMap.size()) &#123;\n            return (0x0000000000000000000000000000000000000000, - 1, - 1, 0, 0, 0, 0, 0);\n        &#125;\n \n        address account &#x3D; tokenHoldersMap.getKeyAtIndex(index);\n \n        return getAccount(account);\n    &#125;\n \n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) &#123;\n        if (lastClaimTime &gt; block.timestamp) &#123;\n            return false;\n        &#125;\n \n        return block.timestamp.sub(lastClaimTime) &gt;&#x3D; claimWait;\n    &#125;\n \n    function setBalance(address payable account, uint256 newBalance) external onlyOwner &#123;\n        if (excludedFromDividends[account]) &#123;\n            return;\n        &#125;\n \n        if (newBalance &gt;&#x3D; minimumTokenBalanceForDividends) &#123;\n            _setBalance(account, newBalance);\n            tokenHoldersMap.set(account, newBalance);\n        &#125;\n        else &#123;\n            _setBalance(account, 0);\n            tokenHoldersMap.remove(account);\n        &#125;\n \n        processAccount(account, true);\n    &#125;\n \n    function process(uint256 gas) public returns (uint256, uint256, uint256) &#123;\n        uint256 numberOfTokenHolders &#x3D; tokenHoldersMap.keys.length;\n \n        if (numberOfTokenHolders &#x3D;&#x3D; 0) &#123;\n            return (0, 0, lastProcessedIndex);\n        &#125;\n \n        uint256 _lastProcessedIndex &#x3D; lastProcessedIndex;\n \n        uint256 gasUsed &#x3D; 0;\n \n        uint256 gasLeft &#x3D; gasleft();\n \n        uint256 iterations &#x3D; 0;\n        uint256 claims &#x3D; 0;\n \n        while (gasUsed &lt; gas &amp;&amp; iterations &lt; numberOfTokenHolders) &#123;\n            _lastProcessedIndex++;\n \n            if (_lastProcessedIndex &gt;&#x3D; tokenHoldersMap.keys.length) &#123;\n                _lastProcessedIndex &#x3D; 0;\n            &#125;\n \n            address account &#x3D; tokenHoldersMap.keys[_lastProcessedIndex];\n \n            if (canAutoClaim(lastClaimTimes[account])) &#123;\n                if (processAccount(payable(account), true)) &#123;\n                    claims++;\n                &#125;\n            &#125;\n \n            iterations++;\n \n            uint256 newGasLeft &#x3D; gasleft();\n \n            if (gasLeft &gt; newGasLeft) &#123;\n                gasUsed &#x3D; gasUsed.add(gasLeft.sub(newGasLeft));\n            &#125;\n \n            gasLeft &#x3D; newGasLeft;\n        &#125;\n \n        lastProcessedIndex &#x3D; _lastProcessedIndex;\n \n        return (iterations, claims, lastProcessedIndex);\n    &#125;\n \n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) &#123;\n        uint256 amount &#x3D; _withdrawDividendOfUser(account);\n \n        if (amount &gt; 0) &#123;\n            lastClaimTimes[account] &#x3D; block.timestamp;\n            emit Claim(account, amount, automatic);\n            return true;\n        &#125;\n \n        return false;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","text":"contract Token is ERC20, Ownable &#123; using SafeMath for uint256; IUniswapV2Router02 public uniswapV2Router; address public immutable unis...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"Solidity","slug":"Solidity","count":5,"path":"api/categories/Solidity.json"}],"tags":[{"name":"区块链","slug":"区块链","count":13,"path":"api/tags/区块链.json"},{"name":"Solidity","slug":"Solidity","count":5,"path":"api/tags/Solidity.json"},{"name":"智能合约","slug":"智能合约","count":2,"path":"api/tags/智能合约.json"}],"toc":"","author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"通缩分红币Safemoon解读","uid":"0611b829126354c2a4ab4275e956e0b0","slug":"通缩分红币Safemoon解读/index","date":"2022-03-18T16:01:39.000Z","updated":"2022-03-24T16:28:14.304Z","comments":true,"path":"api/articles/通缩分红币Safemoon解读/index.json","keywords":null,"cover":null,"text":"1、Safemoon原理Safemoon是一种通缩分红币，通缩指的是每次转账都会收取一定手续费，这些手续费会直接销毁，进而导致总量的通缩。分红指的是，用户的余额会随着其他用户转账而增加。 Safemoon的基本原理用一个比喻来说就是，将一块固定蛋糕（_tTotal）分给总量会变化...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Solidity","slug":"Solidity","count":5,"path":"api/categories/Solidity.json"}],"tags":[{"name":"区块链","slug":"区块链","count":13,"path":"api/tags/区块链.json"},{"name":"Solidity","slug":"Solidity","count":5,"path":"api/tags/Solidity.json"},{"name":"智能合约","slug":"智能合约","count":2,"path":"api/tags/智能合约.json"}],"author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}}},"next_post":{"title":"代币的防机器人机制","uid":"bbdea3a6ec34b778554399878ace6b88","slug":"代币的防机器人机制/index","date":"2022-03-18T15:50:26.000Z","updated":"2022-03-24T16:27:58.218Z","comments":true,"path":"api/articles/代币的防机器人机制/index.json","keywords":null,"cover":null,"text":"solidity防机器人有两种方式一种是根据判断在几区块，另外一种是根据时间来检测 先用第一种判断时间来检测机器人，照例用以前的代码再新加判断机器人的逻辑 &#x2F;&#x2F; SPDX-License-Identifier: MIT pragma solidity ^0.6...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"Solidity","slug":"Solidity","count":5,"path":"api/categories/Solidity.json"}],"tags":[{"name":"区块链","slug":"区块链","count":13,"path":"api/tags/区块链.json"},{"name":"Solidity","slug":"Solidity","count":5,"path":"api/tags/Solidity.json"}],"author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}}}}