{"title":"代币的防机器人机制","uid":"bbdea3a6ec34b778554399878ace6b88","slug":"代币的防机器人机制/index","date":"2022-03-18T15:50:26.000Z","updated":"2022-03-18T15:51:52.207Z","comments":true,"path":"api/articles/代币的防机器人机制/index.json","keywords":null,"cover":null,"content":"<p>solidity防机器人有两种方式一种是根据判断在几区块，另外一种是根据时间来检测</p>\n<p>先用第一种判断时间来检测机器人，照例用以前的代码再新加判断机器人的逻辑</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\nimport &quot;.&#x2F;ERC20.sol&quot;;\ncontract Token is ERC20&#123;\n \n   string private _name;    &#x2F;&#x2F;币名字\n    string private _symbol;      &#x2F;&#x2F;币符号\n    address public deadwallet &#x3D; 0x0000000000000000000000000000000000000000;    &#x2F;&#x2F;销毁地址\n    address public LiquityWallet;            &#x2F;&#x2F;铸币钱包\n    mapping(address &#x3D;&gt; bool) public _isBlacklisted;    &#x2F;&#x2F;是否是黑名单,true表示这个地址是黑名单\n     uint256 public tradingEnabledTimestamp &#x3D; 1627779600; &#x2F;&#x2F;10:00pm       &#x2F;&#x2F;2021-08-1 9:00:00的时间戳，这里设置开盘时间，开盘时间逻辑后面再提，这里先注重防机器人\n    &#x2F;*\n     * @dev 返回代币的名字\n     *&#x2F;\n    function name() public view virtual returns (string memory) &#123;\n        return _name;\n    &#125;\n    &#x2F;**\n     * @dev 返回代币的符号\n     *&#x2F;\n    function symbol() public view virtual returns (string memory) &#123;\n        return _symbol;\n    &#125;\n    &#x2F;**\n     * 返回代币精度\n     *&#x2F;\n    function decimals() public pure virtual returns (uint8) &#123;\n        return 18;\n    &#125;\n    constructor() public&#123;\n        _name&#x3D;&#39;Token&#39;;\n        _symbol&#x3D;&#39;Tk&#39;;\n        _mint(msg.sender, 10000000000000 * (10 ** 18));            &#x2F;&#x2F;铸币给连接此合约的账号于10000000000000个币;\n        LiquityWallet&#x3D;msg.sender;\n    &#125;\n     &#x2F;&#x2F;交易函数\n     function _transfer(address recipient, uint256 amount) public returns (bool) &#123;\n        require(!_isBlacklisted[msg.sender], &#39;Blacklisted address&#39;);      &#x2F;&#x2F;如果发送方是黑名单则禁止交易\n        if(LiquityWallet!&#x3D;msg.sender) return super.transfer(recipient, amount); &#x2F;&#x2F;如果铸币方是发送方则不需要销毁\n         if(block.timestamp &lt;&#x3D; tradingEnabledTimestamp + 9 seconds) &#123;  &#x2F;&#x2F;当前块的时间戳小于等于 可交易时间戳+9秒。\n            addBot(msg.sender);                                   &#x2F;&#x2F;把当前地址添加黑名单\n         &#125;                                 \n        uint256 BurnWallet &#x3D; amount.mul(5).div(100);       &#x2F;&#x2F;销毁百分之5\n        uint256 trueAmount &#x3D; amount.sub(BurnWallet);   &#x2F;&#x2F;剩下的95%就是要发送的\n        super.transfer(deadwallet, BurnWallet);          &#x2F;&#x2F;销毁这百分之5\n        return super.transfer(recipient, trueAmount);     &#x2F;&#x2F;发送那95%的代币\n    &#125;\n    \n    function _transferFrom(address sender, address recipient, uint256 amount) public returns (bool) &#123;\n        require(!_isBlacklisted[msg.sender], &#39;Blacklisted address&#39;);      &#x2F;&#x2F;如果发送方是黑名单则禁止交易\n        if(LiquityWallet!&#x3D;msg.sender) return super.transfer(recipient, amount); &#x2F;&#x2F;如果铸币方是发送方则不需要销毁\n         if(block.timestamp &lt;&#x3D; tradingEnabledTimestamp + 9 seconds) &#123;  &#x2F;&#x2F;当前块的时间戳小于等于 可交易时间戳+9秒。\n            addBot(msg.sender);                                   &#x2F;&#x2F;把当前地址添加黑名单\n         &#125; \n        uint256 BurnWallet &#x3D; amount.mul(5).div(100);       &#x2F;&#x2F;销毁百分之5\n        uint256 trueAmount &#x3D; amount.sub(BurnWallet);       &#x2F;&#x2F;剩下的95就是要发送的\n        super.transferFrom(sender, deadwallet, BurnWallet);   &#x2F;&#x2F;销毁这百分之5\n        return super.transferFrom(sender, recipient, trueAmount);  &#x2F;&#x2F;发送那95%的代币\n    &#125;\n        &#x2F;&#x2F;设置黑名单地址\n    function blacklistAddress(address account, bool value) public &#123;\n        _isBlacklisted[account] &#x3D; value;   &#x2F;&#x2F;如果是true就是黑名单\n    &#125;\n    &#x2F;&#x2F;添加黑名单的函数\n    function addBot(address recipient) private &#123;\n        if (!_isBlacklisted[recipient]) _isBlacklisted[recipient] &#x3D; true;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在上面的代码中防机器人逻辑主要是如果机器人在开盘9秒内买的就拉进黑名单，不给交易。</p>\n<p>第二种方式代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\nimport &quot;.&#x2F;ERC20.sol&quot;;\ncontract Token is ERC20&#123;\n \n   string private _name;    &#x2F;&#x2F;币名字\n    string private _symbol;      &#x2F;&#x2F;币符号\n    address public deadwallet &#x3D; 0x0000000000000000000000000000000000000000;    &#x2F;&#x2F;销毁地址\n    address public LiquityWallet;            &#x2F;&#x2F;铸币钱包\n    mapping(address &#x3D;&gt; bool) public _isBlacklisted;    &#x2F;&#x2F;是否是黑名单,true表示这个地址是黑名单\n     uint256 public tradingEnabledTimestamp &#x3D; 1627779600;       &#x2F;&#x2F;2021-08-1 9:00:00的时间戳，这里设置开盘时间，开盘时间逻辑后面再提，这里先注重防机器人\n     uint256 public launchedAt&#x3D;0;                                   \n    &#x2F;*\n     * @dev 返回代币的名字\n     *&#x2F;\n    function name() public view virtual returns (string memory) &#123;\n        return _name;\n    &#125;\n    &#x2F;**\n     * @dev 返回代币的符号\n     *&#x2F;\n    function symbol() public view virtual returns (string memory) &#123;\n        return _symbol;\n    &#125;\n    &#x2F;**\n     * 返回代币精度\n     *&#x2F;\n    function decimals() public pure virtual returns (uint8) &#123;\n        return 18;\n    &#125;\n    constructor() public&#123;\n        _name&#x3D;&#39;Token&#39;;\n        _symbol&#x3D;&#39;Tk&#39;;\n        _mint(msg.sender, 10000000000000 * (10 ** 18));            &#x2F;&#x2F;铸币给连接此合约的账号于10000000000000个币;\n        LiquityWallet&#x3D;msg.sender;\n    &#125;\n     &#x2F;&#x2F;交易函数\n     function _transfer(address recipient, uint256 amount) public returns (bool) &#123;\n        require(!_isBlacklisted[msg.sender], &#39;Blacklisted address&#39;);      &#x2F;&#x2F;如果发送方是黑名单则禁止交易\n        if(LiquityWallet!&#x3D;msg.sender) return super.transfer(recipient, amount); &#x2F;&#x2F;如果铸币方是发送方则不需要销毁\n        if (launchedAt &#x3D;&#x3D; 0) &#123;   \n            launchedAt &#x3D; block.number;                       &#x2F;&#x2F;初始化lauchAt赋值当前块的数量\n        &#125;\n        if (block.number &lt; launchedAt + 3) &#123;                     &#x2F;&#x2F;如果在3个区间内抢到\n                 addBot(msg.sender);                                    &#x2F;&#x2F;则添加黑名单\n        &#125;                                 \n        uint256 BurnWallet &#x3D; amount.mul(5).div(100);       &#x2F;&#x2F;销毁百分之5\n        uint256 trueAmount &#x3D; amount.sub(BurnWallet);   &#x2F;&#x2F;剩下的95%就是要发送的\n        super.transfer(deadwallet, BurnWallet);          &#x2F;&#x2F;销毁这百分之5\n        return super.transfer(recipient, trueAmount);     &#x2F;&#x2F;发送那95%的代币\n    &#125;\n    \n    function _transferFrom(address sender, address recipient, uint256 amount) public returns (bool) &#123;\n        require(!_isBlacklisted[msg.sender], &#39;Blacklisted address&#39;);      &#x2F;&#x2F;如果发送方是黑名单则禁止交易\n        if(LiquityWallet!&#x3D;msg.sender) return super.transfer(recipient, amount); &#x2F;&#x2F;如果铸币方是发送方则不需要销毁\n         if (launchedAt &#x3D;&#x3D; 0) &#123;   \n            launchedAt &#x3D; block.number;                       &#x2F;&#x2F;初始化lauchAt赋值当前块的数量\n        &#125;\n        if (block.number &lt; launchedAt + 3) &#123;                     &#x2F;&#x2F;如果在3个区间内抢到\n                 addBot(msg.sender);                                    &#x2F;&#x2F;则添加黑名单\n        &#125;\n        uint256 BurnWallet &#x3D; amount.mul(5).div(100);       &#x2F;&#x2F;销毁百分之5\n        uint256 trueAmount &#x3D; amount.sub(BurnWallet);       &#x2F;&#x2F;剩下的95就是要发送的\n        super.transferFrom(sender, deadwallet, BurnWallet);   &#x2F;&#x2F;销毁这百分之5\n        return super.transferFrom(sender, recipient, trueAmount);  &#x2F;&#x2F;发送那95%的代币\n    &#125;\n        &#x2F;&#x2F;设置黑名单地址\n    function blacklistAddress(address account, bool value) public &#123;\n        _isBlacklisted[account] &#x3D; value;   &#x2F;&#x2F;如果是true就是黑名单\n    &#125;\n    &#x2F;&#x2F;添加黑名单的函数\n    function addBot(address recipient) private &#123;\n        if (!_isBlacklisted[recipient]) _isBlacklisted[recipient] &#x3D; true;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","text":"solidity防机器人有两种方式一种是根据判断在几区块，另外一种是根据时间来检测 先用第一种判断时间来检测机器人，照例用以前的代码再新加判断机器人的逻辑 &#x2F;&#x2F; SPDX-License-Identifier: MIT pragma solidity ^0.6...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"Solidity","slug":"Solidity","count":2,"path":"api/categories/Solidity.json"}],"tags":[{"name":"区块链","slug":"区块链","count":7,"path":"api/tags/区块链.json"},{"name":"Solidity","slug":"Solidity","count":2,"path":"api/tags/Solidity.json"}],"toc":"","author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"详解分红其他代币，添加流动性合约","uid":"bb3bf222bcca42dfaadd6e15dbdfbacd","slug":"详解分红其他代币，添加流动性合约/index","date":"2022-03-18T15:55:32.000Z","updated":"2022-03-18T15:56:43.709Z","comments":true,"path":"api/articles/详解分红其他代币，添加流动性合约/index.json","keywords":null,"cover":null,"text":"contract Token is ERC20, Ownable &#123; using SafeMath for uint256; IUniswapV2Router02 public uniswapV2Router; address public immutable unis...","link":"","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"Solidity","slug":"Solidity","count":2,"path":"api/categories/Solidity.json"}],"tags":[{"name":"区块链","slug":"区块链","count":7,"path":"api/tags/区块链.json"},{"name":"Solidity","slug":"Solidity","count":2,"path":"api/tags/Solidity.json"},{"name":"智能合约","slug":"智能合约","count":1,"path":"api/tags/智能合约.json"}],"author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}}},"next_post":{"title":"教你发行BSC链上可分其他代币|含营销钱包|通缩|回流 智能合约","uid":"39ca82df4b5e6da28b6e5b90eb3517e9","slug":"教你发行BSC链上可分其他代币-含营销钱包-通缩-回流-智能合约/index","date":"2022-03-17T18:50:05.000Z","updated":"2022-03-17T18:57:08.042Z","comments":true,"path":"api/articles/教你发行BSC链上可分其他代币-含营销钱包-通缩-回流-智能合约/index.json","keywords":null,"cover":null,"text":"支持分红SHIB ETH USDT DOGE等BSC所有代币。 Remixhttps://remix.ethereum.org/ 编译/开源参数COMPILER: v0.8.4+commit.e28d00a7.js Enable optimization: 开启并使用默认值200...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"发币教程","slug":"发币教程","count":4,"path":"api/categories/发币教程.json"}],"tags":[{"name":"区块链","slug":"区块链","count":7,"path":"api/tags/区块链.json"},{"name":"BSC","slug":"BSC","count":2,"path":"api/tags/BSC.json"},{"name":"教程","slug":"教程","count":4,"path":"api/tags/教程.json"}],"author":{"name":"Bug Designer","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<p><font face=\"微软雅黑\" color=\"red\"><b>QQ：2510472590</b></font></p><p><b>工作时间12:00 - 02:00</b></p>","socials":{"github":"https://github.com/sdzczh","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/zgsdzczh?type=blog","juejin":"","customs":{}}}}}